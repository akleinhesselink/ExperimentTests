} else {
firstRing[j] = NA
}
}
data$firstRing=firstRing
plot(data$radius, firstRing,main=paste0(doSpp,":",nbSpp),ylim=c(0,20),xlab="Genet radius (cm)",ylab="Mid-radius of 1st occupied ring (cm)");
abline(0,1,col="blue");
fit = rq(firstRing~radius-1,data=data,tau=0.05);
abline(fit); fits[[jSpp+4*(iSpp-1)]]=fit;
fac = round(coef(fit)[1], digits=2);
legend("topright",legend=as.character(fac),bty="n",cex=1.2,inset=0.1);
}
}
dev.off()
# loop through species again and analyze no overlap radius
fits<-list(0)
png("NoOverlap.png",height=11,width=8.5,res=400,units="in")
par(mfrow=c(4,4),mgp=c(2,1,0),mar=c(4,4,2,1),cex.axis=1.2,cex.lab=1.2)
for(iSpp in 1:4){
doSpp <- sppList[iSpp]
data <- ringD[[iSpp]]
data$radius = sqrt(data$area/pi);
## Drop individuals very likely to be seedlings
likely.seedling = which((data$age==1)&(data$logarea<=log(0.25001)))
if(length(likely.seedling)>0) data=data[-(likely.seedling), ];
# loop through neighbor species
for(jSpp in 1:4){
nbSpp <- sppList[jSpp]
dataCols = which(substr(names(data),1,4)==nbSpp);
ringData = data[,dataCols];
firstRing = numeric(nrow(data));
for(j in 1:nrow(data)) {
ringj = ringData[j,]
if(sum(ringj)>0) {
firstNonEmpty = min(which(ringj > 0))
firstRing[j] = midRings[firstNonEmpty]
} else {
firstRing[j] = NA
}
}
data$firstRing=firstRing
plot(data$radius, firstRing,main=paste0(doSpp,":",nbSpp),ylim=c(0,20),xlab="Genet radius (cm)",ylab="Mid-radius of 1st occupied ring (cm)");
abline(0,1,col="black");
if(doSpp==nbSpp){
fit = rq(firstRing~radius-1,data=data,tau=0.05);
abline(fit); fits[[iSpp]]=fit;
}
fac = round(coef(fit)[1], digits=2);
legend("topright",legend=as.character(fac),bty="n",cex=1.2,inset=0.1);
}
}
dev.off()
overlapOffsets <- numeric(4)
for(i in 1:4) overlapOffsets[i] <- coef(fits[[i]])[1]
# loop through species again and analyze no overlap radius
fits<-list(0)
png("NoOverlap.png",height=11,width=8.5,res=400,units="in")
par(mfrow=c(4,4),mgp=c(2,1,0),mar=c(4,4,2,1),cex.axis=1.2,cex.lab=1.2)
for(iSpp in 1:4){
doSpp <- sppList[iSpp]
data <- ringD[[iSpp]]
data$radius = sqrt(data$area/pi);
## Drop individuals very likely to be seedlings
likely.seedling = which((data$age==1)&(data$logarea<=log(0.25001)))
if(length(likely.seedling)>0) data=data[-(likely.seedling), ];
# loop through neighbor species
for(jSpp in 1:4){
nbSpp <- sppList[jSpp]
dataCols = which(substr(names(data),1,4)==nbSpp);
ringData = data[,dataCols];
firstRing = numeric(nrow(data));
for(j in 1:nrow(data)) {
ringj = ringData[j,]
if(sum(ringj)>0) {
firstNonEmpty = min(which(ringj > 0))
firstRing[j] = midRings[firstNonEmpty]
} else {
firstRing[j] = NA
}
}
data$firstRing=firstRing
plot(data$radius, firstRing,main=paste0(doSpp,":",nbSpp),ylim=c(0,20),xlab="Genet radius (cm)",ylab="Mid-radius of 1st occupied ring (cm)");
abline(0,1,col="black");
if(doSpp==nbSpp){
fit = rq(firstRing~radius-1,data=data,tau=0.05);
abline(fit,col="red"); fits[[iSpp]]=fit;
}
fac = round(coef(fit)[1], digits=2);
legend("topright",legend=as.character(fac),bty="n",cex=1.2,inset=0.1);
}
}
dev.off()
# loop through species again and analyze no overlap radius
fits<-list(0)
png("NoOverlap.png",height=11,width=8.5,res=400,units="in")
par(mfrow=c(4,4),mgp=c(2,1,0),mar=c(4,4,2,1),cex.axis=1.2,cex.lab=1.2)
for(iSpp in 1:4){
doSpp <- sppList[iSpp]
data <- ringD[[iSpp]]
data$radius = sqrt(data$area/pi);
## Drop individuals very likely to be seedlings
likely.seedling = which((data$age==1)&(data$logarea<=log(0.25001)))
if(length(likely.seedling)>0) data=data[-(likely.seedling), ];
# loop through neighbor species
for(jSpp in 1:4){
nbSpp <- sppList[jSpp]
dataCols = which(substr(names(data),1,4)==nbSpp);
ringData = data[,dataCols];
firstRing = numeric(nrow(data));
for(j in 1:nrow(data)) {
ringj = ringData[j,]
if(sum(ringj)>0) {
firstNonEmpty = min(which(ringj > 0))
firstRing[j] = midRings[firstNonEmpty]
} else {
firstRing[j] = NA
}
}
data$firstRing=firstRing
plot(data$radius, firstRing,main=paste0(doSpp,":",nbSpp),ylim=c(0,20),xlab="Genet radius (cm)",ylab="Mid-radius of 1st occupied ring (cm)");
abline(0,1,col="black");
if(doSpp==nbSpp){
fit = rq(firstRing~radius-1,data=data,tau=0.05);
abline(fit,col="red"); fits[[iSpp]]=fit;
fac = round(coef(fit)[1], digits=2);
legend("bottomright",legend=as.character(fac),bty="n",cex=1.2,inset=0.1);
}
}
}
dev.off()
overlapOffsets <- numeric(4)
for(i in 1:4) overlapOffsets[i] <- coef(fits[[i]])[1]
overlapOffsets
sppList
overlapOffsets=data.frame(species=sppList[1:4],offset=overlapOffsets)
overlapOffsets
getwd()
write.csv(overlapOffsets,"OverlapOffsets.csv",row.names=F)
#####################
#  3. Model W's (with help from Giles Hooker)
####################
# store results of regressions
nonzero.rsq <- matrix(NA,4,6)
row.names(nonzero.rsq) <- sppList[1:4]
zero.dev <-matrix(NA,4,6)
row.names(zero.dev) <- sppList[1:4]
for(doSpp in 1:4){
# grab control treatment data
cD <- subset(allD[[doSpp]],Treatment=="Control")
groupI <- which(cD$Group=="E1") # keep track of this for later
Wdat = cD[,4:ncol(cD)]
Wnonzero = Wdat > 0
# grab data from no shrub plots
trtD <- subset(allD[[doSpp]],Treatment=="No_shrub" & year==2011)
Wdat.trt = trtD[,4:ncol(trtD)]
Wnonzero.trt = Wdat.trt > 0
# scatter plots
filename <- paste0(sppList[doSpp],"_W_scatters.png")
tmp <- rgb(0,100,255,alpha=125,maxColorValue = 255)
myCol <- c(rep(tmp,dim(Wdat)[1]),rep("red3",dim(Wdat.trt)[1]))
png(filename,height=8,width=8,res=400,units="in")
par(tcl=-0.2,mgp=c(2,0.5,0))
allWdat <-rbind(Wdat,Wdat.trt)
pairs(allWdat,col=myCol)
dev.off()
# compare distributions of control and treatment plot W's
filename <- paste0(sppList[doSpp],"_W_byTrt.png")
png(filename,height=5,width=8.5,res=400,units="in")
par(mfrow=c(2,3),tcl=-0.2,mgp=c(2,0.5,0),mar=c(2,2,2,1),oma=c(2,2,0,0))
for(i in 1:6){
dens <- density(log(Wdat[Wnonzero[groupI,i],i])) # just E1 control quads
#dens <- density(W.bc[Wnonzero[,i],i])  # all control quads
dens.trt <- density(log(Wdat.trt[Wnonzero.trt[,i],i]))
ylims <- c(0,1.2*max(c(dens$y,dens.trt$y)))
xlims <- c(min(c(dens$x,dens.trt$x)),max(c(dens$x,dens.trt$x)))
plot(dens,xlab="",ylab="",xlim=xlims,ylim=ylims,main=names(cD)[3+i],col="dodgerblue3")
lines(dens.trt,col="red3")
if(i==6){
mtext("log(W)",side=1,line=0.5,outer=T)
mtext("Density",side=2,line=0.5,outer=T)
}
# add inset
pNonZero <-sum(Wnonzero[groupI,i])/length(Wnonzero[groupI,i]) # just E1 control quads
#pNonZero <-sum(Wnonzero[,i])/length(Wnonzero[,i])  # all control quads
pNonZero.trt <- sum(Wnonzero.trt[,i])/length(Wnonzero.trt[,i])
subplot(barplot(c(pNonZero,pNonZero.trt),names=c("Con","Rem"),ylim=c(0,1),
ylab="p(W>0)",xlab="",col=c("dodgerblue3","red3")),
x=c(xlims[1]+(xlims[2]-xlims[1])/6,xlims[1]+(xlims[2]-xlims[1])/2),
y=c(ylims[2]-(ylims[2]-ylims[1])/5,ylims[2]-(ylims[2]-ylims[1])/20),
par=list(tcl=-0.2,mgp=c(2,0.5,0),mar=c(2,3,0,0)))
}
dev.off()
# Brief analysis -- are there correlations among whether there is a zero or not
cor(Wnonzero) # All pretty tiny.
cor(Wnonzero.trt) # pretty strong negative correlation with HECO
# To analyze the rest, we'll look at Box-Cox transformations - these find lambda
# so that X^lambda is as close to normal as possible. boxcox() in R just produces
# a list of lambdas and the corresponding likelihood so we have to do a bit of
# processing
library(MASS)
W.bc = Wdat  # will store transformed data
W.bc.trt = Wdat.trt
for(i in 1:6){
# Select non-zero entries for this column
t.dat = Wdat[Wnonzero[,i],i]
# boxcox
bc = boxcox(t.dat~1,lambda = seq(-2,2,by=0.01),plotit=FALSE)
# optimal lambda
lambda = bc$x[which.max(bc$y)]
# Add into W.bc
W.bc[Wnonzero[,i],i] = t.dat^lambda
# apply same transformation to treatment plots
W.bc.trt[Wnonzero.trt[,i],i] = Wdat.trt[Wnonzero.trt[,i],i]^lambda
}
# A first analysis: correlation based on rows where there are no zeros
W.all = apply(Wnonzero,1,prod)
cor(W.bc[W.all==1,])
# Just a few correlations larger than 0.1, none over 0.15
# Further analyses are based on conditionals; here we'll regress each column on
# the others, allowing a separate effect for being zero in each. We'll also
# predict whether or not the response is non-zero via a logistic regression.
lm.mods = list()       # Models for non-zeros
glm.mods = list()      # Models to predict whether or not you're zero
Rsq = rep(0,4)         # R-squared for non-zero model
ave.dev = rep(0,4)     # Average drop in deviance per observation
for(i in 1:6){
# Linear regression for non-zeros
t.dat = data.frame(y = W.bc[Wnonzero[,i],i],W.bc[Wnonzero[,i],-i], Wnonzero[Wnonzero[,i],-i])
lm.mods[[i]] = lm(y~.,data=t.dat)
#print(summary(lm.mods[[i]]))
Rsq[i] = summary(lm.mods[[i]])$r.squared
# Generalized Linear regression for whether or not the record is zero
t.dat = data.frame(y = Wnonzero[,i],W.bc[,-i], Wnonzero[,-i])
glm.mods[[i]] = glm(y~.,data=t.dat,family='binomial')
#print(summary(glm.mods[[i]]))
ave.dev[i] = (glm.mods[[i]]$null.deviance - glm.mods[[i]]$deviance)/nrow(t.dat)
}
# Some of these effects are significant, but the change in explanatory power is
# tiny
nonzero.rsq[doSpp,] <-Rsq
zero.dev[doSpp,] <- ave.dev
} # next doSpp
print(nonzero.rsq)
print(max(nonzero.rsq))
print(zero.dev)
print(max(zero.dev))
setwd("..")
# clean up
tmp=ls() ; tmp=tmp[tmp!="root" & tmp!="statsOutput"]
rm(list=tmp)
max.CI <- F  # TRUE means use maximum removal effect
sppList <-  c("ARTR","HECO","POSE","PSSP")
source("ipm/get_W_functions.r")  # get neighbor distance decay functions
overlapOffsets <- read.csv("Wdistrib/OverlapOffsets.csv") # get offsets for extended no-overlap rule
overlapOffsets
offsets <- read.csv("Wdistrib/OverlapOffsets.csv") # get offsets for extended no-overlap rule
offsets <- offsets$offset
offsets
Vectorize
?Vectorize
offsets
max.CI <- F  # TRUE means use maximum removal effect
sppList <-  c("ARTR","HECO","POSE","PSSP")
source("ipm/get_W_functions.r")  # get neighbor distance decay functions
offsets <- read.csv("Wdistrib/OverlapOffsets.csv") # get offsets for extended no-overlap rule
offsets <- offsets$offset
#no treatment effects, all species
init.species <- c(1:4)
tlimit <- 2500
burn.in <- 500
trtEffects=F
source("ipm/IPM-setup.r")
source("ipm/IPM-getEquilibrium.r")
write.csv(covSave[(burn.in+1):tlimit,],"ipm/baselineCover.csv",row.names=F)
meanCover1 <- meanCover
meanCover
median(covSave[(burn.in+1):tlimit,1])
source('C:/Repos/ExperimentTests/removals/ipm/IPM-getEquilibrium.r', echo=TRUE)
old=Wmat[[ii]]
old
Wmat[[ii]][,ii]=Wrii(v.r[[ii]],ii,1)/A
Wmat[ii]
###
### 5. get equilibrium cover from an IPM ###############################
###
max.CI <- F  # TRUE means use maximum removal effect
sppList <-  c("ARTR","HECO","POSE","PSSP")
source("ipm/get_W_functions.r")  # get neighbor distance decay functions
offsets <- read.csv("Wdistrib/OverlapOffsets.csv") # get offsets for extended no-overlap rule
offsets <- offsets$offset
#no treatment effects, all species
init.species <- c(1:4)
tlimit <- 2500
burn.in <- 500
trtEffects=F
source("ipm/IPM-setup.r")
source("ipm/IPM-getEquilibrium.r")
write.csv(covSave[(burn.in+1):tlimit,],"ipm/baselineCover.csv",row.names=F)
meanCover1 <- meanCover
#no treatment effects, ARTR removal
init.species <- c(2:4)
source("ipm/IPM-getEquilibrium.r")
write.csv(covSave[(burn.in+1):tlimit,],"ipm/baselineCover-noARTR.csv",row.names=F)
meanCover2 <- meanCover
# removal treatment effects, ARTR removal
init.species <- c(2:4)
trtEffects=T
max.CI=F
source("ipm/IPM-setup.r")
source("ipm/IPM-getEquilibrium.r")
write.csv(covSave[(burn.in+1):tlimit,],"ipm/removalCover-noARTR.csv",row.names=F)
meanCover3 <- meanCover
# removal treatment effects, ARTR removal, max treat effect
init.species <- c(2:4)
trtEffects=T
max.CI=T
source("ipm/IPM-setup.r")
source("ipm/IPM-getEquilibrium.r")
write.csv(covSave[(burn.in+1):tlimit,],"ipm/removalCover-noARTR-maxCI.csv",row.names=F)
meanCover4 <- meanCover
# # removal treatment effects, ARTR removal, no PSSP
# init.species <- c(2:3)
# trtEffects=T
# max.CI=F
# source("ipm/IPM-setup.r")
# source("ipm/IPM-getEquilibrium.r")
# write.csv(covSave[(burn.in+1):tlimit,],"ipm/removalCover-noARTRnoPSSP.csv",row.names=F)
simResults <- rbind(meanCover1,meanCover2,meanCover3)
colnames(simResults) <- sppList
write.csv(simResults,"ipm/simResults-meanCover.csv",row.names=F)
simResults <- rbind(meanCover1,meanCover2,meanCover4)
colnames(simResults) <- sppList
write.csv(simResults,"ipm/simResults-meanCover-maxCI.csv",row.names=F)
simFile <- "ipm/simResults-meanCover.csv"
source("ipm/IPM-figures.r")
# clean up
tmp=ls() ; tmp=tmp[tmp!="root" & tmp!="statsOutput"]
rm(list=tmp)
###
### 5. get equilibrium cover from an IPM ###############################
###
max.CI <- F  # TRUE means use maximum removal effect
sppList <-  c("ARTR","HECO","POSE","PSSP")
source("ipm/get_W_functions.r")  # get neighbor distance decay functions
offsets <- read.csv("Wdistrib/OverlapOffsets.csv") # get offsets for extended no-overlap rule
offsets <- offsets$offset
#no treatment effects, all species
init.species <- c(1:4)
tlimit <- 2500
burn.in <- 500
trtEffects=F
source("ipm/IPM-setup.r")
source("ipm/IPM-getEquilibrium.r")
write.csv(covSave[(burn.in+1):tlimit,],"ipm/baselineCover.csv",row.names=F)
meanCover1 <- meanCover
#no treatment effects, ARTR removal
init.species <- c(2:4)
source("ipm/IPM-getEquilibrium.r")
write.csv(covSave[(burn.in+1):tlimit,],"ipm/baselineCover-noARTR.csv",row.names=F)
meanCover2 <- meanCover
# removal treatment effects, ARTR removal
init.species <- c(2:4)
trtEffects=T
max.CI=F
source("ipm/IPM-setup.r")
source("ipm/IPM-getEquilibrium.r")
write.csv(covSave[(burn.in+1):tlimit,],"ipm/removalCover-noARTR.csv",row.names=F)
meanCover3 <- meanCover
# removal treatment effects, ARTR removal, max treat effect
init.species <- c(2:4)
trtEffects=T
max.CI=T
source("ipm/IPM-setup.r")
source("ipm/IPM-getEquilibrium.r")
write.csv(covSave[(burn.in+1):tlimit,],"ipm/removalCover-noARTR-maxCI.csv",row.names=F)
meanCover4 <- meanCover
# # removal treatment effects, ARTR removal, no PSSP
# init.species <- c(2:3)
# trtEffects=T
# max.CI=F
# source("ipm/IPM-setup.r")
# source("ipm/IPM-getEquilibrium.r")
# write.csv(covSave[(burn.in+1):tlimit,],"ipm/removalCover-noARTRnoPSSP.csv",row.names=F)
simResults <- rbind(meanCover1,meanCover2,meanCover3)
colnames(simResults) <- sppList
write.csv(simResults,"ipm/simResults-meanCover.csv",row.names=F)
simResults <- rbind(meanCover1,meanCover2,meanCover4)
colnames(simResults) <- sppList
write.csv(simResults,"ipm/simResults-meanCover-maxCI.csv",row.names=F)
simFile <- "ipm/simResults-meanCover.csv"
source("ipm/IPM-figures.r")
source('C:/Repos/ExperimentTests/removals/removal_analysis_wrapper.r', echo=TRUE)
# clean up
tmp=ls() ; tmp=tmp[tmp!="root" & tmp!="statsOutput"]
rm(list=tmp)
###
### 4. get IBM predictions for quadrat cover ###############################
###
sppList <-  c("ARTR","HECO","POSE","PSSP")
# read in distance weights
dists <- read.csv(paste0(root,"/driversdata/data/idaho_modern/speciesdata/IdahoModDistanceWeights_noExptl.csv"))
max.CI <- F  # TRUE means use maximum removal effect
source("ibm/ibm_removal_1step.r")
source("ibm/summarize_sims1step.r")
max.CI <- T  # TRUE means use maximum removal effect
source("ibm/ibm_removal_1step.r")
source("ibm/summarize_sims1step.r")
# clean up
tmp=ls() ; tmp=tmp[tmp!="root" & tmp!="statsOutput"]
rm(list=tmp)
getwd()
getwd("..")
setwd("..")
# clean up
tmp=ls() ; tmp=tmp[tmp!="root" & tmp!="statsOutput"]
rm(list=tmp)
###
### 4. get IBM predictions for quadrat cover ###############################
###
sppList <-  c("ARTR","HECO","POSE","PSSP")
# read in distance weights
dists <- read.csv(paste0(root,"/driversdata/data/idaho_modern/speciesdata/IdahoModDistanceWeights_noExptl.csv"))
max.CI <- F  # TRUE means use maximum removal effect
source("ibm/ibm_removal_1step.r")
source("ibm/summarize_sims1step.r")
max.CI <- T  # TRUE means use maximum removal effect
source("ibm/ibm_removal_1step.r")
source("ibm/summarize_sims1step.r")
# clean up
tmp=ls() ; tmp=tmp[tmp!="root" & tmp!="statsOutput"]
rm(list=tmp)
# clean up
tmp=ls() ; tmp=tmp[tmp!="root" & tmp!="statsOutput"]
rm(list=tmp)
###
### 4. get IBM predictions for quadrat cover ###############################
###
sppList <-  c("ARTR","HECO","POSE","PSSP")
# read in distance weights
dists <- read.csv(paste0(root,"/driversdata/data/idaho_modern/speciesdata/IdahoModDistanceWeights_noExptl.csv"))
max.CI <- F  # TRUE means use maximum removal effect
source("ibm/ibm_removal_1step.r")
source("ibm/summarize_sims1step.r")
max.CI <- T  # TRUE means use maximum removal effect
source("ibm/ibm_removal_1step.r")
source("ibm/summarize_sims1step.r")
# clean up
tmp=ls() ; tmp=tmp[tmp!="root" & tmp!="statsOutput"]
rm(list=tmp)
getwd()
setwd("..")
# clean up
tmp=ls() ; tmp=tmp[tmp!="root" & tmp!="statsOutput"]
rm(list=tmp)
###
### 4. get IBM predictions for quadrat cover ###############################
###
sppList <-  c("ARTR","HECO","POSE","PSSP")
# read in distance weights
dists <- read.csv(paste0(root,"/driversdata/data/idaho_modern/speciesdata/IdahoModDistanceWeights_noExptl.csv"))
max.CI <- F  # TRUE means use maximum removal effect
source("ibm/ibm_removal_1step.r")
source("ibm/summarize_sims1step.r")
max.CI <- T  # TRUE means use maximum removal effect
source("ibm/ibm_removal_1step.r")
source("ibm/summarize_sims1step.r")
# clean up
tmp=ls() ; tmp=tmp[tmp!="root" & tmp!="statsOutput"]
rm(list=tmp)
getwd()
source('C:/Repos/ExperimentTests/removals/ibm/summarize_sims1step.r', echo=TRUE)
setwd("..")
max.CI=F
source('C:/Repos/ExperimentTests/removals/ibm/summarize_sims1step.r', echo=TRUE)
getwd()
max.CI <- T  # TRUE means use maximum removal effect
source("ibm/ibm_removal_1step.r")
source("ibm/summarize_sims1step.r")
rm(list=ls())
root=ifelse(.Platform$OS.type=="windows","c:/Repos","~/repos"); # modify as needed
setwd(paste(root,"/ExperimentTests/removals/",sep="")); # modify as needed
sppList <-  c("ARTR","HECO","POSE","PSSP")
# read in distance weights
dists <- read.csv(paste0(root,"/driversdata/data/idaho_modern/speciesdata/IdahoModDistanceWeights_noExptl.csv"))
max.CI <- F  # TRUE means use maximum removal effect
source("ibm/ibm_removal_1step.r")
getwd()
source("ibm/summarize_sims1step.r")
getwd()
max.CI <- T  # TRUE means use maximum removal effect
source("ibm/ibm_removal_1step.r")
setwd("..")
sppList <-  c("ARTR","HECO","POSE","PSSP")
# read in distance weights
dists <- read.csv(paste0(root,"/driversdata/data/idaho_modern/speciesdata/IdahoModDistanceWeights_noExptl.csv"))
max.CI <- F  # TRUE means use maximum removal effect
source("ibm/ibm_removal_1step.r")
source("ibm/summarize_sims1step.r")
max.CI <- T  # TRUE means use maximum removal effect
source("ibm/ibm_removal_1step.r")
source("ibm/summarize_sims1step.r")
getwd()
setwd("removals")
sppList <-  c("ARTR","HECO","POSE","PSSP")
# read in distance weights
dists <- read.csv(paste0(root,"/driversdata/data/idaho_modern/speciesdata/IdahoModDistanceWeights_noExptl.csv"))
max.CI <- F  # TRUE means use maximum removal effect
source("ibm/ibm_removal_1step.r")
source("ibm/summarize_sims1step.r")
max.CI <- T  # TRUE means use maximum removal effect
source("ibm/ibm_removal_1step.r")
source("ibm/summarize_sims1step.r")
