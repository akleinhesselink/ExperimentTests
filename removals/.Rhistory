cov.obs <- reshape(cov.obs,idvar=c("quad","year"),direction="wide",timevar="species")
cov.obs[is.na(cov.obs)] <- 0
head(cov.obs)
# Predict survival and growth of each plant and recruitment in each quadrat*year
# PBA 5/25/2016
outfile="ibm/simulations1step/ObsPred_1step.csv"
# FORMAT PARAMETERS ------------------------------------------------
Nspp=length(sppList)
curDir <- getwd()
Nyrs <- 31
# set up survival parameters and function
source("survival/import2ibm_1step.r")
# set up growth parameters and function
source("growth/import2ibm_1step.r")
# set up recruitment parameters and function
source("recruitment/import2ibm_1step.r")
setwd(curDir)
# FUNCTIONS---------------------------------------------------------
library(boot)
library(mvtnorm)
library(msm)
source("survival/fetchSurvData.r")
# GET OBSERVED DATA  -------------------------------------------
Nspp=length(sppList)
plants=NULL
neighborList <- c("ARTR","HECO","POSE","PSSP","allcov","allpts")
dists$allcov <- rowMeans(dists[,1:4])  # for "other" polygons use average of big 4
dists$allpts <- dists$POSE  # set forb dist wts = smallest grass (POSE)
dataDir2 <- paste(root,"/driversdata/data/idaho_modern",sep="")
for(i in 1:length(sppList)){
doSpp <- sppList[i]
D2 <- fetchSdat(doSpp=doSpp,speciesList=neighborList,datadir=dataDir2,distWts=dists)
# merge in treatment data
tmp <- read.csv(paste(dataDir2,"/quad_info.csv",sep=""))
tmp <- tmp[,c("quad","Treatment")]
D2 <- merge(D2,tmp, all.x=T)
# drop rainfall treatment plots
ii <- which(D2$Treatment=="Drought" | D2$Treatment=="Irrigation")
D2 <- D2[-ii,]
# account for removal in baseline years and take out removed plants
if(doSpp!="ARTR"){
ii <- which(D2$year>=2011 & D2$Treatment=="No_shrub")
D2$W.ARTR[ii] <- 0
ii <- which(D2$Treatment=="No_grass")
D2<-D2[-ii,]
}else{
ii <- which(D2$year>=2011 & D2$Treatment=="No_grass")
D2$W.HECO[ii] <- 0 ; D2$W.POSE[ii] <- 0 ; D2$W.PSSP[ii] <- 0
ii <- which(D2$Treatment=="No_shrub")
D2<-D2[-ii,]
}
D2$area <- exp(D2$logarea)
D2$doSpp <- doSpp
D2 <- subset(D2,year>2010)
plants <- rbind(plants,D2)
}
# get quadrat group and treatment
quad.info <- unique(plants[,c("quad","Group","Treatment")],MARGIN=2)
# merge in quad codes
tmp<-data.frame(Group=c("E1","P1","P10E1","P1E1","P2","P7E1"),GroupCode=c(1:6))
quad.info <- merge(quad.info,tmp)
# add GroupCode to plants data frame too
plants <- merge(plants,tmp)
# aggregate to quadrat and year
cov.obs <- aggregate(plants$area,by=list(species=plants$doSpp,quad=plants$quad,year=plants$year),FUN=sum)
names(cov.obs)[4] <- "obs"
cov.obs$obs <- cov.obs$obs/100 # convert to % cover
cov.obs <- reshape(cov.obs,idvar=c("quad","year"),direction="wide",timevar="species")
cov.obs[is.na(cov.obs)] <- 0
cov.obs <- cov.obs[,c(1,2,6,3,4,5)] # reorder columns
# get 2015 quadrat cover totals (these are not in the survival data file)
tmp <- read.csv("QuadYearCover.csv")
tmp <- subset(tmp, year==2015)
# set removed spp to zero
tmp$cover[tmp$species=="Artemisia tripartita" & tmp$Treatment=="No_shrub"] <- 0
tmp$cover[tmp$species!="Artemisia tripartita" & tmp$Treatment=="No_grass"] <- 0
tmp <- tmp[,c("quad","year","species","cover")] # drop Treatment and Group columns
tmp <- reshape(tmp, idvar=c("quad","year"),timevar="species",direction="wide")
names(tmp) <- names(cov.obs)
cov.obs <-rbind(cov.obs,tmp)
# SURVIVAL AND GROWTH
plants$surv.prob <- plants$surv.prob.trt <- NA
plants$logarea.pred <- plants$logarea.pred.trt <- NA
W.index <- grep("W.",names(plants))
for(k in 1:dim(plants)[1]){
doYr <- which(Spars$yrList==plants$year[k])
doSpp <- which(sppList==plants$species[k])
#ignore treatment effects
plants$surv.prob[k]=survive(Spars,doSpp=doSpp,doGroup=plants$GroupCode[k],
doYear=doYr,sizes=plants$logarea[k],crowding=plants[k,W.index],Treatment="Control")
plants$logarea.pred[k] <- grow(Gpars,doSpp=doSpp,doGroup=plants$GroupCode[k],
doYear=doYr,sizes=plants$logarea[k],crowding=plants[k,W.index],Treatment="Control")
#use treatment effects when appropriate
plants$surv.prob.trt[k]=survive(Spars,doSpp=doSpp,doGroup=plants$GroupCode[k],
doYear=doYr,sizes=plants$logarea[k],crowding=plants[k,W.index],Treatment=plants$Treatment[k])
plants$logarea.pred.trt[k] <- grow(Gpars,doSpp=doSpp,doGroup=plants$GroupCode[k],
doYear=doYr,sizes=plants$logarea[k],crowding=plants[k,W.index],Treatment=plants$Treatment[k])
}
# multiply predicted size by survival probability to get expected area
plants$area.pred <- plants$surv.prob*exp(plants$logarea.pred)
plants$area.pred.trt <- plants$surv.prob.trt*exp(plants$logarea.pred.trt)
# aggregate predicted area to quadrat level
cov.pred <- aggregate(plants[,c("area.pred","area.pred.trt")],by=list(species=plants$doSpp,quad=plants$quad,year=plants$year),FUN=sum)
names(cov.pred)[4:5] <- c("pred","pred.trt")
cov.pred[,4:5] <- cov.pred[,4:5]/100 # convert to % cover
cov.pred <- reshape(cov.pred,idvar=c("quad","year"),direction="wide",timevar="species")
cov.pred[is.na(cov.pred)] <- 0
# loop through observed cover matrix
out.recruit <- out.recruit.trt <- data.frame(quad=cov.obs$quad,year=as.numeric(cov.obs$year),matrix(NA,dim(cov.obs)[1],4))
names(out.recruit)[3:6] <- sppList
names(out.recruit.trt)[3:6] <- sppList
out.recruit <- subset(out.recruit,year<2016); out.recruit.trt <- subset(out.recruit.trt,year<2015)
for(k in 1:dim(out.recruit)[1]){
totArea <- cov.obs[which(cov.obs$year==out.recruit$year[k] & cov.obs$quad==out.recruit$quad[k]),3:6]
doYr<- which(Spars$yrList==cov.obs$year[k])
qI <- which(quad.info$quad==cov.obs$quad[k])
doGroup <- quad.info$GroupCode[qI]
Trt <- quad.info$Treatment[qI]
# no treatment effects
out.recruit[k,3:6]=recruit(Rpars,totArea=as.numeric(cov.obs[k,3:6]),
doGroup=doGroup,doYear=doYr,Treatment="Control")
# with trtEffects as appropriate
out.recruit.trt[k,3:6]=recruit(Rpars,totArea=as.numeric(cov.obs[k,3:6]),
doGroup=doGroup,doYear=doYr,Treatment=Trt)
} # next k
#reorder columns
tmp <- sort(names(cov.pred)[3:NCOL(cov.pred)],index.return=T)$ix
cov.pred <- cov.pred[,c(1,2,(2+tmp))]
# make sure rows are ordered
cov.pred <- cov.pred[order(cov.pred$quad,cov.pred$year),]
out.recruit <- out.recruit[order(out.recruit$quad,out.recruit$year),]
out.recruit.trt <- out.recruit.trt[order(out.recruit.trt$quad,out.recruit.trt$year),]
cbind(cov.pred[,c(1,2)],out.recruit[,c(1,2)],out.recruit.trt[,c(1,2)]) # check rows
# now add together
cov.pred[,3:6] <- cov.pred[,3:6] + out.recruit[,c(3:6)]
cov.pred[,7:10] <- cov.pred[,7:10] + out.recruit.trt[,c(3:6)]
# FORMAT OUTPUT -------------------------------------------------------
# merge observed and predicted cover
cov.pred$year <- cov.pred$year + 1
output <- merge(cov.obs,cov.pred,all=T)
# add in quad.info
output <- merge(output,quad.info)
write.table(output,outfile,row.names=F,sep=",")
rm(plants)
View(cov.obs)
View(cov.pred)
head(cov.pred)
head(out.recruit)
View(cov.pred)
unique(cov.pred$quad)
unique(out.recruit$quad)
length(unique(out.recruit$quad))
View(out.recruit)
# loop through observed cover matrix
out.recruit <- out.recruit.trt <- data.frame(quad=cov.obs$quad,year=as.numeric(cov.obs$year),matrix(NA,dim(cov.obs)[1],4))
names(out.recruit)[3:6] <- sppList
names(out.recruit.trt)[3:6] <- sppList
out.recruit <- subset(out.recruit,year<2016); out.recruit.trt <- subset(out.recruit.trt,year<2016)
for(k in 1:dim(out.recruit)[1]){
totArea <- cov.obs[which(cov.obs$year==out.recruit$year[k] & cov.obs$quad==out.recruit$quad[k]),3:6]
doYr<- which(Spars$yrList==cov.obs$year[k])
qI <- which(quad.info$quad==cov.obs$quad[k])
doGroup <- quad.info$GroupCode[qI]
Trt <- quad.info$Treatment[qI]
# no treatment effects
out.recruit[k,3:6]=recruit(Rpars,totArea=as.numeric(cov.obs[k,3:6]),
doGroup=doGroup,doYear=doYr,Treatment="Control")
# with trtEffects as appropriate
out.recruit.trt[k,3:6]=recruit(Rpars,totArea=as.numeric(cov.obs[k,3:6]),
doGroup=doGroup,doYear=doYr,Treatment=Trt)
} # next k
View(out.recruit)
out.recruit <- out.recruit.trt <- data.frame(quad=cov.obs$quad,year=as.numeric(cov.obs$year),matrix(NA,dim(cov.obs)[1],4))
out.recruit
source('C:/Repos/ExperimentTests/removals/ibm/ibm_removal_1step.r', echo=TRUE)
source("ibm/summarize_sims1step.r")
# call from validate wrapper
setwd("ibm/")
sppList=c("ARTR","HECO","POSE","PSSP")
Nspp=length(sppList)
sppNames=c("A. tripartita","H. comata","Poa secunda","P. spicata")
myCol=c("black","forestgreen","blue","red")
simD <- read.csv("simulations1step/ObsPred_1step.csv")
quad.info <- unique(simD[,c("quad","Treatment","Group")],MARGIN=2)
covMeans <- aggregate(simD[,3:14],by=list(Treatment=simD$Treatment,year=simD$year),
na.rm=T,FUN=mean)
covMeans
covMeans[1:3,7:14] <- covMeans[1:3,3:6] # copy initial values across
covMeans
covMeans <- covMeans[order(covMeans$Treatment),]
get.pgr <- function(myname){
tmp<- simD[,c("quad","year",paste0(myname,sppList))]
tmp$year <- tmp$year-1
names(tmp)[3:6] <-paste0("next.",sppList)
tmp2 <- merge(simD[,c(1:6)],tmp)
out <- cbind(tmp2[,c("quad","year")],log(tmp2[,7:10]/tmp2[,3:6]))
out[out==Inf | out==-Inf] <- NA
out
}
obs.pgr <- get.pgr("obs.")
pred.pgr <- get.pgr("pred.")
pred.trt.pgr <- get.pgr("pred.trt.")
get.trt.means<-function(mydat){
mydat<-merge(mydat,quad.info)
out <- aggregate(mydat[,3:6],by=list(Treatment=mydat$Treatment,year=mydat$year),
FUN=mean,na.rm=T)
out <- out[order(out$Treatment,out$year),]
#consolidate removal treatments
out[5:8,4:6] <- out[9:12,4:6]
out <- out[-c(9:12),]
out$Treatment <- as.character(out$Treatment)
out$Treatment[5:8] <- "Removal"
out
}
obs.pgr.mean <- get.trt.means(obs.pgr)
pred.pgr.mean <- get.trt.means(pred.pgr)
pred.trt.pgr.mean <- get.trt.means(pred.trt.pgr)
covMeans
source('C:/Repos/ExperimentTests/removals/ibm/summarize_sims1step.r', echo=TRUE)
setwd("..")
source('C:/Repos/ExperimentTests/removals/ibm/summarize_sims1step.r', echo=TRUE)
obs.pgr.mean
obs.pgr
obs.pgr.mean <- get.trt.means(obs.pgr)
pred.pgr.mean <- get.trt.means(pred.pgr)
pred.trt.pgr.mean <- get.trt.means(pred.trt.pgr)
obs.pgr.mean
get.trt.means<-function(mydat){
mydat<-merge(mydat,quad.info)
out <- aggregate(mydat[,3:6],by=list(Treatment=mydat$Treatment,year=mydat$year),
FUN=mean,na.rm=T)
out <- out[order(out$Treatment,out$year),]
#consolidate removal treatments
out[5:9,4:6] <- out[10:14,4:6]
out <- out[-c(10:14),]
out$Treatment <- as.character(out$Treatment)
out$Treatment[5:9] <- "Removal"
out
}
obs.pgr.mean <- get.trt.means(obs.pgr)
pred.pgr.mean <- get.trt.means(pred.pgr)
pred.trt.pgr.mean <- get.trt.means(pred.trt.pgr)
obs.pgr.mean
mydat<-obs.pgr
mydat<-merge(mydat,quad.info)
out <- aggregate(mydat[,3:6],by=list(Treatment=mydat$Treatment,year=mydat$year),
FUN=mean,na.rm=T)
out <- out[order(out$Treatment,out$year),]
out
mydat<-merge(mydat,quad.info)
out <- aggregate(mydat[,3:6],by=list(Treatment=mydat$Treatment,year=mydat$year),
FUN=mean,na.rm=T)
out <- out[order(out$Treatment,out$year),]
#consolidate removal treatments
out[6:10,4:6] <- out[11:15,4:6]
out <- out[-c(11:15),]
out$Treatment <- as.character(out$Treatment)
out$Treatment[6:10] <- "Removal"
out
mydat<-merge(mydat,quad.info)
out <- aggregate(mydat[,3:6],by=list(Treatment=mydat$Treatment,year=mydat$year),
FUN=mean,na.rm=T)
out <- out[order(out$Treatment,out$year),]
warnings()
mydat
mydat<-merge(mydat,quad.info)
out <- aggregate(mydat[,3:6],by=list(Treatment=mydat$Treatment,year=mydat$year),
FUN=mean,na.rm=T)
out
obs.pgr <- get.pgr("obs.")
mydat<-merge(mydat,quad.info)
out <- aggregate(mydat[,3:6],by=list(Treatment=mydat$Treatment,year=mydat$year),
FUN=mean,na.rm=T)
head(obs.pgr)
mydat<-merge(mydat,quad.info)
head(mydat)
rm(list=ls())
sppList=c("ARTR","HECO","POSE","PSSP")
Nspp=length(sppList)
sppNames=c("A. tripartita","H. comata","Poa secunda","P. spicata")
myCol=c("black","forestgreen","blue","red")
simD <- read.csv("simulations1step/ObsPred_1step.csv")
quad.info <- unique(simD[,c("quad","Treatment","Group")],MARGIN=2)
### calculate mean cover by treatment
covMeans <- aggregate(simD[,3:14],by=list(Treatment=simD$Treatment,year=simD$year),
na.rm=T,FUN=mean)
covMeans[1:3,7:14] <- covMeans[1:3,3:6] # copy initial values across
covMeans <- covMeans[order(covMeans$Treatment),]
### calculate per capita growth rates
get.pgr <- function(myname){
tmp<- simD[,c("quad","year",paste0(myname,sppList))]
tmp$year <- tmp$year-1
names(tmp)[3:6] <-paste0("next.",sppList)
tmp2 <- merge(simD[,c(1:6)],tmp)
out <- cbind(tmp2[,c("quad","year")],log(tmp2[,7:10]/tmp2[,3:6]))
out[out==Inf | out==-Inf] <- NA
out
}
obs.pgr <- get.pgr("obs.")
pred.pgr <- get.pgr("pred.")
pred.trt.pgr <- get.pgr("pred.trt.")
head(obs.pgr)
mydat<-obs.pgr
mydat<-merge(mydat,quad.info)
head(mydat)
mydat<-merge(mydat,quad.info)
out <- aggregate(mydat[,3:6],by=list(Treatment=mydat$Treatment,year=mydat$year),
FUN=mean,na.rm=T)
out <- out[order(out$Treatment,out$year),]
#consolidate removal treatments
out[6:10,4:6] <- out[11:15,4:6]
out <- out[-c(11:15),]
out$Treatment <- as.character(out$Treatment)
out$Treatment[6:10] <- "Removal"
out
mydat<-obs.pgr
head(mydat)
mydat<-merge(mydat,quad.info)
head(mydat)
out <- aggregate(mydat[,3:6],by=list(Treatment=mydat$Treatment,year=mydat$year),
FUN=mean,na.rm=T)
out
out <- out[order(out$Treatment,out$year),]
out
out[6:10,4:6] <- out[11:15,4:6]
out
out <- out[-c(11:15),]
out
out$Treatment <- as.character(out$Treatment)
out$Treatment[6:10] <- "Removal"
out
obs.pgr <- get.pgr("obs.")
pred.pgr <- get.pgr("pred.")
pred.trt.pgr <- get.pgr("pred.trt.")
# aggregate by treatment
get.trt.means<-function(mydat){
mydat<-merge(mydat,quad.info)
out <- aggregate(mydat[,3:6],by=list(Treatment=mydat$Treatment,year=mydat$year),
FUN=mean,na.rm=T)
out <- out[order(out$Treatment,out$year),]
#consolidate removal treatments
out[6:10,4:6] <- out[11:15,4:6]
out <- out[-c(11:15),]
out$Treatment <- as.character(out$Treatment)
out$Treatment[6:10] <- "Removal"
out
}
obs.pgr.mean <- get.trt.means(obs.pgr)
pred.pgr.mean <- get.trt.means(pred.pgr)
pred.trt.pgr.mean <- get.trt.means(pred.trt.pgr)
###
### plot observed and predicted cover chronologically
###
png("cover_projections_1step.png",res=400,width=8.5,height=3,units="in")
par(mfrow=c(1,4),tcl=0.2,mgp=c(2,0.5,0),mar=c(2,2,2,1),oma=c(2,2,0,0))
for(i in 1:4){
if(i==1){
doRows <- which(covMeans$Treatment=="No_grass")
}else{
doRows <- which(covMeans$Treatment=="No_shrub")
}
matplot(covMeans$year[1:6],cbind(covMeans[1:6,2+i],covMeans[1:6,6+i], # control plots
covMeans[doRows,2+i],covMeans[doRows,6+i],covMeans[doRows,10+i]),
xlab="",ylab="",type="l",
lty=c("solid","dashed","solid","dashed","dotted"),
col=c(rep("blue3",2),rep("red3",3)))   # removal plots
title(main=sppNames[i],adj=0,font.main=4)
if(i==3){
legend("bottomleft",c("Obs. control","Baseline","Obs. removal","Baseline","Removal"),
col=c(rep("blue3",2),rep("red3",3)),
lty=c("solid","dashed","solid","dashed","dotted"),bty="n")
}
}
mtext("Year",side=1,line=0.5,outer=T,cex=1)
mtext("Cover (%)",side=2,line=0.5,outer=T,cex=1)
dev.off()
###
### plot growth rates chronologically
###
plotObsPred<-function(doSpp,mytitle,doLegend=F){
# format data
newD=data.frame(year=2011:2015,obs.pgr.mean[obs.pgr.mean$Treatment=="Control",2 + doSpp],
pred.pgr.mean[pred.pgr.mean$Treatment=="Control",2+doSpp],
obs.pgr.mean[obs.pgr.mean$Treatment=="Removal",2+doSpp],
pred.pgr.mean[pred.pgr.mean$Treatment=="Removal",2+doSpp],
pred.trt.pgr.mean[pred.trt.pgr.mean$Treatment=="Removal",2+doSpp])                               # removal pred (with TRT effect)
names(newD)=c("year","control.obs","control.pred","remove.obs","remove.pred","remove.predTRT")
color1=rgb(0,100,255,alpha=175,maxColorValue = 255)
color2=rgb(153,0,0,alpha=175,maxColorValue = 255)
my.y <- c(-1.2,1) # hard wire ylims
matplot(newD$year,newD[,2:6],type="o",xlab="",ylab="",ylim=my.y,
col=c(rep(color1,2),rep(color2,3)),xaxt="n",
pch=c(16,21,16,21,24),bg="white",
lty=c("solid","dotted","solid","dotted","dotted"))
axis(1,at=c(2011:2015))
abline(h=0,lty="solid",col="darkgray")
# add standard error bars to observed means
#   arrows(x0=mysd1$year,y0=c(mydata1[,1+doSpp]-mysd1[,1+doSpp]/sqrt(14)), # 14 = number of control plots
#          x1=mysd1$year,y1=c(mydata1[,1+doSpp]+mysd1[,1+doSpp]/sqrt(14)),length=0.05,angle=90,code=3,col=color1)
#   arrows(x0=mysd2$year,y0=c(mydata2[,1+doSpp]-mysd2[,1+doSpp]/sqrt(8)), # 8 = number of control plots
#          x1=mysd2$year,y1=c(mydata2[,1+doSpp]+mysd2[,1+doSpp]/sqrt(8)),length=0.05,angle=90,code=3,col=color2)
title(main=mytitle,adj=0,font.main=4)
if(doLegend==T){
legend("bottomleft",c("Control","Baseline model","Removal","Baseline model","Removal model"),
col=c(rep(color1,2),rep(color2,3)), pch=c(16,21,16,21,24),pt.bg = "white",
lty=c("solid","dotted","solid","dotted","dotted"),bty="n")
}
}
png("cover_change_chrono.png",units="in",height=3,width=8.5,res=600)
par(mfrow=c(1,4),tcl=-0.2,mgp=c(2,0.5,0),mar=c(2,2,2,1),oma=c(2,2,0,0))
plotObsPred(1,sppNames[1],doLegend=T)
plotObsPred(2,sppNames[2])
plotObsPred(3,sppNames[3])
plotObsPred(4,sppNames[4])
mtext(side=1,"Year",line=0.5, outer=T)
mtext(side=2,expression(paste("Mean ",log(Cover[t+1]/Cover[t]))),line=0, outer=T)
dev.off()
setwd("..")
max.CI <- F  # TRUE means use maximum removal effect
sppList <-  c("ARTR","HECO","POSE","PSSP")
source("ibm/get_W_functions.r")  # get neighbor distance decay functions
#no treatment effects, all species
init.species <- c(1:4)
tlimit <- 2500
burn.in <- 500
trtEffects=F
source("ipm/IPM-setup.r")
source("ipm/IPM-getEquilibrium.r")
write.csv(covSave[(burn.in+1):tlimit,],"ipm/baselineCover.csv",row.names=F)
meanCover1 <- meanCover
rm(list=ls(all=TRUE))
graphics.off();
root=ifelse(.Platform$OS.type=="windows","c:/Repos","~/repos"); # modify as needed
setwd(paste(root,"/ExperimentTests/removals/",sep="")); # modify as needed
max.CI <- F  # TRUE means use maximum removal effect
sppList <-  c("ARTR","HECO","POSE","PSSP")
source("ibm/get_W_functions.r")  # get neighbor distance decay functions
#no treatment effects, all species
init.species <- c(1:4)
tlimit <- 2500
burn.in <- 500
trtEffects=F
source("ipm/IPM-setup.r")
source("ipm/IPM-getEquilibrium.r")
###
### 5. get equilibrium cover from an IPM ###############################
###
max.CI <- F  # TRUE means use maximum removal effect
sppList <-  c("ARTR","HECO","POSE","PSSP")
source("ibm/get_W_functions.r")  # get neighbor distance decay functions
#no treatment effects, all species
init.species <- c(1:4)
tlimit <- 2500
burn.in <- 500
trtEffects=F
source("ipm/IPM-setup.r")
source("ipm/IPM-getEquilibrium.r")
write.csv(covSave[(burn.in+1):tlimit,],"ipm/baselineCover.csv",row.names=F)
meanCover1 <- meanCover
#no treatment effects, ARTR removal
init.species <- c(2:4)
source("ipm/IPM-getEquilibrium.r")
write.csv(covSave[(burn.in+1):tlimit,],"ipm/baselineCover-noARTR.csv",row.names=F)
meanCover2 <- meanCover
# removal treatment effects, ARTR removal
init.species <- c(2:4)
trtEffects=T
max.CI=F
source("ipm/IPM-setup.r")
source("ipm/IPM-getEquilibrium.r")
write.csv(covSave[(burn.in+1):tlimit,],"ipm/removalCover-noARTR.csv",row.names=F)
meanCover3 <- meanCover
# removal treatment effects, ARTR removal, max treat effect
init.species <- c(2:4)
trtEffects=T
max.CI=T
source("ipm/IPM-setup.r")
source("ipm/IPM-getEquilibrium.r")
write.csv(covSave[(burn.in+1):tlimit,],"ipm/removalCover-noARTR-maxCI.csv",row.names=F)
meanCover4 <- meanCover
# # removal treatment effects, ARTR removal, no PSSP
# init.species <- c(2:3)
# trtEffects=T
# max.CI=F
# source("ipm/IPM-setup.r")
# source("ipm/IPM-getEquilibrium.r")
# write.csv(covSave[(burn.in+1):tlimit,],"ipm/removalCover-noARTRnoPSSP.csv",row.names=F)
simResults <- rbind(meanCover1,meanCover2,meanCover3)
colnames(simResults) <- sppList
write.csv(simResults,"ipm/simResults-meanCover.csv",row.names=F)
simResults <- rbind(meanCover1,meanCover2,meanCover4)
colnames(simResults) <- sppList
write.csv(simResults,"ipm/simResults-meanCover-maxCI.csv",row.names=F)
simFile <- "ipm/simResults-meanCover.csv"
source("ipm/IPM-figures.r")
rm(list=ls(all=TRUE))
graphics.off();
root=ifelse(.Platform$OS.type=="windows","c:/Repos","~/repos"); # modify as needed
setwd(paste(root,"/ExperimentTests/removals/",sep="")); # modify as needed
statsOutput <- paste0(getwd(),"/stats_tables.tex")
library("TeachingDemos") # for inset plots
library("quantreg")
source("Wdistrib/exploreSurvivalWs.R")
rm(list=ls())
D=read.csv("H:\idahochart_remapping\betaData\records\allrecords_density.csv")
D=read.csv("H:\\idahochart_remapping\\betaData\\records\\allrecords_density.csv")
head(D)
subD=subset(D,Species=="Artemisia tripartita" & Seedling="Y")
subD=subset(D,Species=="Artemisia tripartita" & Seedling=="Y")
table(subD$year)
View(subD)
View(subD)
