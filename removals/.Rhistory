keep <- which(is.element(allD$Treatment,c("Control","No_grass")))
}else{
keep <- which(is.element(allD$Treatment,c("Control","No_shrub")))
}
allD <- allD[keep,]
# remove outliers (large plants that obviously do not turn into tiny plants)
#########################################
#  2. Fit models
#########################################
library(lme4)
# set up indicator variables
allD$Treatment2 <- allD$Treatment
allD$Treatment2[allD$year>2000] <- "Modern"
allD$Treatment3 <- allD$Treatment
allD$Treatment3[allD$Treatment=="Control" & allD$year>2000] <- "ControlModern"
allD$year <- as.factor(allD$year)
# explore treatment effects
m0 <- lmer(logarea.t1~logarea.t0 + W.ARTR + W.HECO + W.POSE + W.PSSP+ W.allcov + W.allpts+
(1|Group)+(logarea.t0|year),data=allD)
m1 <- lmer(logarea.t1~logarea.t0+ Treatment + W.HECO + W.POSE + W.PSSP+ W.ARTR + W.allcov + W.allpts+
(1|Group)+(logarea.t0|year),data=allD)
m2 <- lmer(logarea.t1~logarea.t0+ Treatment + W.HECO + W.POSE + W.PSSP+ W.ARTR + W.allcov + W.allpts+
W.HECO:Treatment+
(1|Group)+(logarea.t0|year),data=allD)
m3 <- lmer(logarea.t1~logarea.t0+ Treatment + W.HECO + W.POSE + W.PSSP+ W.ARTR + W.allcov + W.allpts+
W.POSE:Treatment+ W.HECO:Treatment+W.PSSP:Treatment+
(1|Group)+(logarea.t0|year),data=allD)
print(c(AIC(m0),AIC(m1),AIC(m2),AIC(m3)))
summary(m2)
source('C:/Repos/ExperimentTests/removals/growth/ARTRgrowth_Wresids.R', echo=TRUE)
source('C:/Repos/ExperimentTests/removals/growth/ARTRgrowth_Wresids.R', echo=TRUE)
source('C:/Repos/ExperimentTests/removals/growth/HECO_growth_WvsResids.R', echo=TRUE)
# PBA March 2016
# call from removal_analysis_wrapper.r
#########################################
#  1. Import data and calculate W's
#########################################
doSpp <- "PSSP"
sppList <- c("ARTR","HECO","POSE","PSSP","allcov","allpts")
dataDir1 <- paste(root,"/driversdata/data/idaho",sep="")
dataDir2 <- paste(root,"/driversdata/data/idaho_modern",sep="")
nonCompLength.s=5 #Number of columns in SppData that are not measures of competitors
# set up distance weights------------------------------------------------
#dists <- read.csv(paste(dataDir1,"/speciesdata/IdahoDistanceWeights.csv",sep=""));
dists <- read.csv(paste(dataDir2,"/speciesdata/IdahoModDistanceWeights.csv",sep=""));
dists$allcov <- rowMeans(dists[,1:4])  # for "other" polygons use average of big 4
dists$allpts <- dists$POSE  # set forb dist wts = smallest grass (POSE)
# import old data--------------------------------------------------------
source("fetchGrowthData.r")
D1 <- fetchGdat(doSpp=doSpp,speciesList=sppList,datadir=dataDir1,distWts=dists)
D1$Treatment <- "Control"
# import modern data--------------------------------------------------------
D2 <- fetchGdat(doSpp=doSpp,speciesList=sppList,datadir=dataDir2,distWts=dists)
# merge in treatment data
tmp <- read.csv(paste(dataDir2,"/quad_info.csv",sep=""))
tmp <- tmp[,c("quad","Treatment")]
D2 <- merge(D2,tmp, all.x=T)
# account for removal in baseline years
if(doSpp!="ARTR"){
ii <- which(D2$year>=2011 & D2$Treatment=="No_shrub")
D2$W.ARTR[ii] <- 0
}else{
ii <- which(D2$year>=2011 & D2$Treatment=="No_grass")
D2$W.HECO[ii] <- 0 ; D2$W.POSE[ii] <- 0 ; D2$W.PSSP[ii] <- 0
}
# combine old and modern
allD <- rbind(D1,D2)
rm(D1,D2,tmp)
# merge data on removals at individual level
tmp <- read.csv(paste(dataDir2,"/speciesData/",doSpp,"/",doSpp,"_within_ARTRremovals.csv",sep=""))
tmp <- tmp[,c("quad","year","trackID","inARTR")]
allD<-merge(allD,tmp,all.x=T)
allD$inARTR[is.na(allD$inARTR)] <- 0
# clean up dataset ----------------------------------------------
allD$year[allD$year<2000] <- allD$year[allD$year<2000] + 1900
if(doSpp=="ARTR"){
keep <- which(is.element(allD$Treatment,c("Control","No_grass")))
}else{
keep <- which(is.element(allD$Treatment,c("Control","No_shrub")))
}
allD <- allD[keep,]
# remove outliers (large plants that obviously do not turn into tiny plants)
#########################################
#  2. Fit models
#########################################
library(lme4)
# set up indicator variables
allD$Treatment2 <- allD$Treatment
allD$Treatment2[allD$year>2000] <- "Modern"
allD$Treatment3 <- allD$Treatment
allD$Treatment3[allD$Treatment=="Control" & allD$year>2000] <- "ControlModern"
allD$year <- as.factor(allD$year)
# use INLA
# Set up ID variables for INLA random effects
allD$GroupID <- as.numeric(allD$Group)
allD$yearID <- 100+as.numeric(allD$year) # for random year offset on intercept
# baseline model
# m0 <- inla(logarea.t1 ~ logarea.t0+ W.ARTR + W.HECO + W.POSE + W.PSSP + W.allcov + W.allpts +
#   f(yearID, model="iid", prior="normal",param=c(0,0.001))+
#   f(GroupID, model="iid", prior="normal",param=c(0,0.001))+
#   f(year, logarea.t0, model="iid", prior="normal",param=c(0,0.001)), data=allD,
#   family=c("gaussian"), verbose=FALSE,
#   control.predictor = list(link = 1),control.compute=list(dic=T,mlik=T),
#   control.inla = list(h = 1e-10),Ntrials=rep(1,nrow(allD)))
# Treatment effect
m1 <- inla(logarea.t1 ~ logarea.t0 + Treatment + W.ARTR + W.HECO + W.POSE + W.PSSP + W.allcov + W.allpts +
f(yearID, model="iid", prior="normal",param=c(0,0.001))+
f(GroupID, model="iid", prior="normal",param=c(0,0.001))+
f(year, logarea.t0, model="iid", prior="normal",param=c(0,0.001)), data=allD,
family=c("gaussian"), verbose=FALSE,
control.predictor = list(link = 1),control.compute=list(dic=T,mlik=T),
control.inla = list(h = 1e-10),Ntrials=rep(1,nrow(allD)))
# Explore alternative covariates and models using lmer
m0.lmer <- lmer(logarea.t1~logarea.t0+W.ARTR + W.HECO + W.POSE + W.PSSP+ W.allcov + W.allpts+
(1|Group)+(logarea.t0|year),data=allD)
m1.lmer <- lmer(logarea.t1~logarea.t0+Treatment+W.ARTR + W.HECO + W.POSE + W.PSSP+W.allcov + W.allpts+
(1|Group)+(logarea.t0|year),data=allD)
m2.lmer <- lmer(logarea.t1~logarea.t0+ Treatment + W.HECO + W.POSE + W.PSSP+ W.ARTR + W.allcov + W.allpts+
W.PSSP:Treatment+
(1|Group)+(logarea.t0|year),data=allD)
m3.lmer <- lmer(logarea.t1~logarea.t0+ Treatment + W.HECO + W.POSE + W.PSSP+ W.ARTR + W.allcov + W.allpts+
W.POSE:Treatment+ W.HECO:Treatment+W.PSSP:Treatment+
(1|Group)+(logarea.t0|year),data=allD)
print(c(AIC(m0),AIC(m1),AIC(m2),AIC(m3)))  # m2 is best
print(c(AIC(m0.lmer),AIC(m1.lmer),AIC(m2.lmer),AIC(m3.lmer)))  # m2 is best
# fit better model with INLA
m.best <- inla(logarea.t1 ~ logarea.t0 + Treatment + W.ARTR + W.HECO + W.POSE + W.PSSP +
W.allcov + W.allpts + W.PSSP:Treatment +
f(yearID, model="iid", prior="normal",param=c(0,0.001))+
f(GroupID, model="iid", prior="normal",param=c(0,0.001))+
f(year, logarea.t0, model="iid", prior="normal",param=c(0,0.001)), data=allD,
family=c("gaussian"), verbose=FALSE,
control.predictor = list(link = 1),control.compute=list(dic=T,mlik=T),
control.inla = list(h = 1e-10),Ntrials=rep(1,nrow(allD)))
names(m.best)
m.best$summary.fixed
m2.new.lmer <- update(m2.lmer,~ . + inARTR)
summary(m1.new.lmer)
summary(m2.new.lmer)
# PBA March 2016
# call from removal_analysis_wrapper.r
#########################################
#  1. Import data and calculate W's
#########################################
doSpp <- "POSE"
sppList <- c("ARTR","HECO","POSE","PSSP","allcov","allpts")
dataDir1 <- paste(root,"/driversdata/data/idaho",sep="")
dataDir2 <- paste(root,"/driversdata/data/idaho_modern",sep="")
nonCompLength.s=5 #Number of columns in SppData that are not measures of competitors
# set up distance weights------------------------------------------------
dists <- read.csv(paste(dataDir2,"/speciesdata/IdahoModDistanceWeights.csv",sep=""));
dists$allcov <- rowMeans(dists[,1:4])  # for "other" polygons use average of big 4
dists$allpts <- dists$POSE  # set forb dist wts = smallest grass (POSE)
# import old data--------------------------------------------------------
source("fetchGrowthData.r")
D1 <- fetchGdat(doSpp=doSpp,speciesList=sppList,datadir=dataDir1,distWts=dists)
D1$Treatment <- "Control"
# import modern data--------------------------------------------------------
D2 <- fetchGdat(doSpp=doSpp,speciesList=sppList,datadir=dataDir2,distWts=dists)
# merge in treatment data
tmp <- read.csv(paste(dataDir2,"/quad_info.csv",sep=""))
tmp <- tmp[,c("quad","Treatment")]
D2 <- merge(D2,tmp, all.x=T)
# account for removal in baseline years
if(doSpp!="ARTR"){
ii <- which(D2$year>=2011 & D2$Treatment=="No_shrub")
D2$W.ARTR[ii] <- 0
}else{
ii <- which(D2$year>=2011 & D2$Treatment=="No_grass")
D2$W.HECO[ii] <- 0 ; D2$W.POSE[ii] <- 0 ; D2$W.PSSP[ii] <- 0
}
# combine old and modern
allD <- rbind(D1,D2)
rm(D1,D2,tmp)
# merge data on removals at individual level
tmp <- read.csv(paste(dataDir2,"/speciesData/",doSpp,"/",doSpp,"_within_ARTRremovals.csv",sep=""))
tmp <- tmp[,c("quad","year","trackID","inARTR")]
allD<-merge(allD,tmp,all.x=T)
allD$inARTR[is.na(allD$inARTR)] <- 0
# clean up dataset ----------------------------------------------
allD$year[allD$year<2000] <- allD$year[allD$year<2000] + 1900
if(doSpp=="ARTR"){
keep <- which(is.element(allD$Treatment,c("Control","No_grass")))
}else{
keep <- which(is.element(allD$Treatment,c("Control","No_shrub")))
}
allD <- allD[keep,]
# remove outliers (large plants that obviously do not turn into tiny plants)
#########################################
#  2. Fit models
#########################################
library(lme4)
# set up indicator variables
allD$Treatment2 <- allD$Treatment
allD$Treatment2[allD$year>2000] <- "Modern"
allD$Treatment3 <- allD$Treatment
allD$Treatment3[allD$Treatment=="Control" & allD$year>2000] <- "ControlModern"
allD$year <- as.factor(allD$year)
# use INLA
# Set up ID variables for INLA random effects
allD$GroupID <- as.numeric(allD$Group)
allD$yearID <- 100+as.numeric(allD$year) # for random year offset on intercept
# Treatment effect
m1 <- inla(logarea.t1 ~ logarea.t0 + Treatment + W.ARTR + W.HECO + W.POSE + W.PSSP + W.allcov + W.allpts +
f(yearID, model="iid", prior="normal",param=c(0,0.001))+
#  f(GroupID, model="iid", prior="normal",param=c(0,0.001))+
f(year, logarea.t0, model="iid", prior="normal",param=c(0,0.001)), data=allD,
family=c("gaussian"), verbose=FALSE,
control.predictor = list(link = 1),control.compute=list(dic=T,mlik=T),
control.inla = list(h = 1e-10),Ntrials=rep(1,nrow(allD)))
# explore alternative models with lmer
m0.lmer <- lmer(logarea.t1~logarea.t0+W.ARTR + W.HECO + W.POSE + W.PSSP+ W.allcov + W.allpts +
(logarea.t0|year),data=allD)
m1.lmer <- lmer(logarea.t1~logarea.t0+Treatment+W.ARTR + W.HECO + W.POSE + W.PSSP+ W.allcov + W.allpts +
(logarea.t0|year),data=allD)
m2.lmer <- lmer(logarea.t1~logarea.t0+ Treatment + W.HECO + W.POSE + W.PSSP+ W.ARTR + W.allcov + W.allpts+
W.POSE:Treatment+
(1|Group)+(logarea.t0|year),data=allD)
m3.lmer <- lmer(logarea.t1~logarea.t0+ Treatment + W.HECO + W.POSE + W.PSSP+ W.ARTR + W.allcov + W.allpts+
W.POSE:Treatment+ W.HECO:Treatment+W.PSSP:Treatment+
(1|Group)+(logarea.t0|year),data=allD)
print(c(AIC(m0.lmer),AIC(m1.lmer),AIC(m2.lmer),AIC(m3.lmer))) # m2 is best
source("write_params.r") # get function to format and output parameters
for(iSpp in c("ARTR","HECO","POSE","PSSP")){
source(paste0(iSpp,"growth.r"))
# save treatment test
irow <- dim(trtTests)[1]
trtTests[irow+1,] <- NA
trtTests[irow+1,1:2] <- c(iSpp,"growth")
tmp <- grep("Treatment",row.names(m1$summary.fixed))
trtTests[irow+1,3:5] <- m1$summary.fixed[tmp,c("mean","0.025quant","0.975quant")]
# write parameters for best model
formatGrowthPars(m.best,paste0(iSpp,"_growth_Trt.csv"))
}
# call all scripts for removal experiment analysis
rm(list=ls(all=TRUE))
graphics.off();
root=ifelse(.Platform$OS.type=="windows","c:/Repos","~/repos"); # modify as needed
setwd(paste(root,"/ExperimentTests/removals/",sep="")); # modify as needed
###
### 1. get treatment trends #################################
###
source("treatment_trends_removals.r")
###
### 2. fit vital rate regressions ###########################
###
# table to store Treatment effects
trtTests <- data.frame("species"="c","stage"="c","effect"=1,"CI.02.5"=1,"CI.97.5"=1,stringsAsFactors = F)
# fit growth models (takes < 5 mins)
library(lme4)
library(INLA)
setwd("growth")
source("write_params.r") # get function to format and output parameters
for(iSpp in c("ARTR","HECO","POSE","PSSP")){
source(paste0(iSpp,"growth.r"))
# save treatment test
irow <- dim(trtTests)[1]
trtTests[irow+1,] <- NA
trtTests[irow+1,1:2] <- c(iSpp,"growth")
tmp <- grep("Treatment",row.names(m1$summary.fixed))
trtTests[irow+1,3:5] <- m1$summary.fixed[tmp,c("mean","0.025quant","0.975quant")]
# write parameters for best model
formatGrowthPars(m.best,paste0(iSpp,"_growth_Trt.csv"))
}
setwd("..")
# call from "removal_analysis_wrapper.r"
#============================================================
# SIMULATION PARAMETERS
#============================================================
A=10000 #Area of 100cm x 100cm quadrat
sppList=c("ARTR","HECO","POSE","PSSP")
bigM=c(75,75,50,50)     #Set matrix dimension for each species
maxSize=c(3000,202,260,225)    # in cm^2: PSSP=225 HECO=202  POSE=260  ARTR=3000  # minSize=0.2  cm^2
Nyrs=30
doGroup=NA  # NA for spatial avg., values 1-6 for a specific group
#============================================================
# LOAD VITAL RATE PARAMETERS & FUNCTIONS
#============================================================
Nspp=length(sppList)
Gpars=list(intcpt=rep(NA,Nspp),intcpt.yr=matrix(0,Nyrs,Nspp),intcpt.gr=matrix(0,6,Nspp),intcpt.trt=rep(0,Nspp),
slope=rep(NA,Nspp),slope.yr=matrix(0,Nyrs,Nspp),
nb=matrix(0,Nspp,Nspp),sigma2.a=rep(NA,Nspp),sigma2.b=rep(NA,Nspp))
Nspp=4
infile=paste0("growth/",sppList[i],"_growth.csv")
Gdata=read.csv(infile)
# main intercept
Gpars$intcpt[i]=Gdata$X.Intercept.[1]
# random year effects on intercept
Gpars$intcpt.yr[,i]=Gdata$Intercept.yr
Gpars
infile=paste0("growth/",sppList[i],"_growth.csv")
Gdata=read.csv(infile)
# main intercept
Gpars$intcpt[i]=Gdata$X.Intercept.[1]
# random year effects on intercept
Gpars$intcpt.yr[,i]=Gdata$Intercept.yr
# group effects
tmp=which(names(Gdata)=="Group")
if(length(tmp)>0) Gpars$intcpt.gr[,i]=Gdata$Group[!is.na(Gdata$Group)]
# size slope
Gpars$slope[i]=Gdata$logarea.t0[1]
# random effects on slope
tmp=which(names(Gdata)=="logarea.yr")
if(length(tmp)>0) Gpars$slope.yr[,i]=Gdata[,tmp]
# get competition coefficients
tmp=paste("W",sppList,sep=".")
tmp=which(is.element(names(Gdata),tmp))
if(length(tmp)>0) Gpars$nb[i,]=as.numeric(Gdata[1,tmp])
tmp=grep("Treatment",names(Gdata))
tmp
Gdata[1,tmp]
Gpars$nb
# Treatment effects
tmp=grep("Treatment",names(Gdata))
if(length(tmp)==1) Gpars$intcpt[i]=Gpars$intcpt[i] + Gdata[1,tmp[1]] # add treatment intercept
if(length(tmp)==2) Gpars$nb[i,i]=Gpars$nb[i,i] + Gdata[1,tmp[2]] # add treatment density dependence
if(length(tmp)>2) stop("too many treatment effects")
Gpars$intcpt
infile=paste0("growth/",sppList[i],"_growth.csv")
Gdata=read.csv(infile)
# main intercept
Gpars$intcpt[i]=Gdata$X.Intercept.[1]
# random year effects on intercept
Gpars$intcpt.yr[,i]=Gdata$Intercept.yr
# group effects
tmp=which(names(Gdata)=="Group")
if(length(tmp)>0) Gpars$intcpt.gr[,i]=Gdata$Group[!is.na(Gdata$Group)]
# size slope
Gpars$slope[i]=Gdata$logarea.t0[1]
# random effects on slope
tmp=which(names(Gdata)=="logarea.yr")
if(length(tmp)>0) Gpars$slope.yr[,i]=Gdata[,tmp]
# get competition coefficients
tmp=paste("W",sppList,sep=".")
tmp=which(is.element(names(Gdata),tmp))
if(length(tmp)>0) Gpars$nb[i,]=as.numeric(Gdata[1,tmp])
# Treatment effects
tmp=grep("Treatment",names(Gdata))
if(length(tmp)>0) Gpars$intcpt[i]=Gpars$intcpt[i] + Gdata[1,tmp[1]] # add treatment intercept
if(length(tmp)>1) Gpars$nb[i,i]=Gpars$nb[i,i] + Gdata[1,tmp[2]] # add treatment density dependence
if(length(tmp)>2) stop("too many treatment effects")
Gpars
source('C:/Repos/ExperimentTests/removals/growth/import2ibm_deterministic.r', echo=TRUE)
source('C:/Repos/ExperimentTests/removals/growth/import2ibm_deterministic.r', echo=TRUE)
Gpars
# call all scripts for removal experiment analysis
rm(list=ls(all=TRUE))
graphics.off();
root=ifelse(.Platform$OS.type=="windows","c:/Repos","~/repos"); # modify as needed
setwd(paste(root,"/ExperimentTests/removals/",sep="")); # modify as needed
###
### 1. get treatment trends #################################
###
source("treatment_trends_removals.r")
###
### 2. fit vital rate regressions ###########################
###
# table to store Treatment effects
trtTests <- data.frame("species"="c","stage"="c","effect"=1,"CI.02.5"=1,"CI.97.5"=1,stringsAsFactors = F)
# fit growth models (takes < 5 mins)
library(lme4)
library(INLA)
setwd("growth")
source("write_params.r") # get function to format and output parameters
for(iSpp in c("ARTR","HECO","POSE","PSSP")){
source(paste0(iSpp,"growth.r"))
# save treatment test
irow <- dim(trtTests)[1]
trtTests[irow+1,] <- NA
trtTests[irow+1,1:2] <- c(iSpp,"growth")
tmp <- grep("Treatment",row.names(m1$summary.fixed))
trtTests[irow+1,3:5] <- m1$summary.fixed[tmp,c("mean","0.025quant","0.975quant")]
# write parameters for best model
formatGrowthPars(m.best,paste0(iSpp,"_growth.csv"))
}
setwd("..")
#============================================================
# SIMULATION PARAMETERS
#============================================================
A=10000 #Area of 100cm x 100cm quadrat
sppList=c("ARTR","HECO","POSE","PSSP")
bigM=c(75,75,50,50)     #Set matrix dimension for each species
maxSize=c(3000,202,260,225)    # in cm^2: PSSP=225 HECO=202  POSE=260  ARTR=3000  # minSize=0.2  cm^2
Nyrs=30
doGroup=NA  # NA for spatial avg., values 1-6 for a specific group
#============================================================
# LOAD VITAL RATE PARAMETERS & FUNCTIONS
#============================================================
Nspp=length(sppList)
# set up survival parameters and function
source("survival/import2ipm_noOverlap.r")
# set up growth parameters and function
source("growth/import2ipm_noOverlap.r")
# set up recruitment parameters and function
source("recruitment/import2ipm.r")
trtEffects=T
#============================================================
# SIMULATION PARAMETERS
#============================================================
A=10000 #Area of 100cm x 100cm quadrat
sppList=c("ARTR","HECO","POSE","PSSP")
bigM=c(75,75,50,50)     #Set matrix dimension for each species
maxSize=c(3000,202,260,225)    # in cm^2: PSSP=225 HECO=202  POSE=260  ARTR=3000  # minSize=0.2  cm^2
Nyrs=30
doGroup=NA  # NA for spatial avg., values 1-6 for a specific group
#============================================================
# LOAD VITAL RATE PARAMETERS & FUNCTIONS
#============================================================
Nspp=length(sppList)
# set up survival parameters and function
source("survival/import2ipm_noOverlap.r")
# set up growth parameters and function
source("growth/import2ipm_noOverlap.r")
# set up recruitment parameters and function
source("recruitment/import2ipm.r")
Gpars
trtEffects=F
#============================================================
# SIMULATION PARAMETERS
#============================================================
A=10000 #Area of 100cm x 100cm quadrat
sppList=c("ARTR","HECO","POSE","PSSP")
bigM=c(75,75,50,50)     #Set matrix dimension for each species
maxSize=c(3000,202,260,225)    # in cm^2: PSSP=225 HECO=202  POSE=260  ARTR=3000  # minSize=0.2  cm^2
Nyrs=30
doGroup=NA  # NA for spatial avg., values 1-6 for a specific group
#============================================================
# LOAD VITAL RATE PARAMETERS & FUNCTIONS
#============================================================
Nspp=length(sppList)
# set up survival parameters and function
source("survival/import2ipm_noOverlap.r")
# set up growth parameters and function
source("growth/import2ipm_noOverlap.r")
# set up recruitment parameters and function
source("recruitment/import2ipm.r")
Gpars
###
### 4. get IBM predictions for quadrat cover ###############################
###
sppList <-  c("ARTR","HECO","POSE","PSSP")
source("validate/get_W_functions.r")  # get neighbor distance decay functions
# do contemporary control plots
quadList <- paste0("Q",c(1:6,19:26))
groupList <- c(rep(1,6),rep(6,4),rep(3,4))
removeSpp <- NULL
trtEffects <- FALSE  # TRUE means use a model that includes removal treatment effects
for(iQuad in 1:length(quadList)){
qName=quadList[iQuad]
doGroup=groupList[iQuad]
source("validate/ibm_validate_removal.r")   # project forward from 2011
source("validate/ibm_validate_removal_1step.r")  # just predict one time step ahead for each year
}
# do no grass plots
quadList <- c("Q48","Q49","Q51","Q55","Q57","Q58","Q60","Q62")  # no grass
removeSpp <- c("HECO","POSE","PSSP")
for(iQuad in quadList){
qName=iQuad
doGroup=1
trtEffects <- FALSE
source("validate/ibm_validate_removal.r")
source("validate/ibm_validate_removal_1step.r")
trtEffects <- TRUE
source("validate/ibm_validate_removal.r")
source("validate/ibm_validate_removal_1step.r")
}
# do no shrub plots
quadList <- c("Q47","Q50","Q52","Q53","Q54","Q56","Q59","Q61")  # no shrub
removeSpp <- c("ARTR")
for(iQuad in quadList){
qName=iQuad
doGroup=1
trtEffects <- FALSE
source("validate/ibm_validate_removal.r")
source("validate/ibm_validate_removal_1step.r")
trtEffects <- TRUE
source("validate/ibm_validate_removal.r")
source("validate/ibm_validate_removal_1step.r")
}
# make figure for simulation results
source("validate/summarize_validate_sims1step.r")
###
### 5. get equilibrium cover from an IPM ###############################
###
sppList <-  c("ARTR","HECO","POSE","PSSP")
source("validate/get_W_functions.r")  # get neighbor distance decay functions
#no treatment effects, all species
init.species <- c(1:4)
tlimit <- 2500
burn.in <- 500
trtEffects=F
source("ipm/IPM-setup.r")
source("ipm/IPM-getEquilibrium.r")
write.csv(covSave[(burn.in+1):tlimit,],"ipm/baselineCover.csv",row.names=F)
meanCover1 <- meanCover
#no treatment effects, ARTR removal
init.species <- c(2:4)
source("ipm/IPM-getEquilibrium.r")
write.csv(covSave[(burn.in+1):tlimit,],"ipm/baselineCover-noARTR.csv",row.names=F)
meanCover2 <- meanCover
# removal treatment effects, ARTR removal
init.species <- c(2:4)
trtEffects=T
source("ipm/IPM-setup.r")
source("ipm/IPM-getEquilibrium.r")
write.csv(covSave[(burn.in+1):tlimit,],"ipm/removalCover-noARTR.csv",row.names=F)
meanCover3 <- meanCover
simResults <- rbind(meanCover1,meanCover2,meanCover3)
colnames(simResults) <- sppList
write.csv(simResults,"ipm/simResults-meanCover.csv",row.names=F)
source("ipm/IPM-figures.r")
Gpars
