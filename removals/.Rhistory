K.matrix=make.K.matrix(v[[doSpp]],Wmat[[doSpp]],Rpars,rpa,Gpars,Spars,doYear,doSpp)
new.nt[[doSpp]]=K.matrix%*%nt[[doSpp]]
sizeSave[[doSpp]][,i]=new.nt[[doSpp]]/sum(new.nt[[doSpp]])
}
} # next species
is.matrix(Wmat[[1]])
W=Wmat[[1]]
is.matrix(W)
W%*%c(1,1,1,1)
is.numeric(W)
is.list(W)
source('C:/Repos/drivers/StorageEffectEmpirical/multispp_glm_v3/ipm_noOverlap.r', echo=TRUE)
source('C:/Repos/drivers/StorageEffectEmpirical/multispp_glm_v3/ipm_noOverlap.r', echo=TRUE)
W=Wmat[[1]]
W
#calculate size-specific crowding
alpha=Spars$alpha
if(NoOverlap.Inter==F){
for(ii in 1:Nspp){
# first do all overlap W's
Xbar=cover*A/N       # multiply by A to get cover back in cm^2
varX=varN(v,nt,h,Xbar,N)
muW = pi*Xbar*N/(A*alpha[ii,])
muW[is.na(muW)]=0
Wmat[[ii]]=matrix(muW,nrow=length(v[[ii]]),ncol=Nspp,byrow=T)
# now do conspecific no overlap W
Ctot[ii]=h[ii]*sum(expv[[ii]]*nt[[ii]])
Cr[[ii]]=splinefun(b.r[[ii]],h[ii]*c(0,cumsum(expv[[ii]]*nt[[ii]])),method="natural")
Wmat[[ii]][,ii]=Wrij(v.r[[ii]],ii,ii)/A
}
}else{
for(ii in 1:Nspp){
Ctot[ii]=h[ii]*sum(expv[[ii]]*nt[[ii]])
Cr[[ii]]=splinefun(b.r[[ii]],h[ii]*c(0,cumsum(expv[[ii]]*nt[[ii]])),method="natural")
}
for(jj in 1:Nspp){
Wfun=splinefun(size.range,Wrij(size.range,jj,jj))
for(ii in 1:Nspp) {
Wmat[[ii]][,jj]=Wfun(v.r[[ii]])/A
}
}
} # end NoOverlap if
W=Wmat[[1]]
W
is.matrix(W)
is.numeric(W)
alpha
# call all scripts for removal experiment analysis
rm(list=ls(all=TRUE))
graphics.off();
root=ifelse(.Platform$OS.type=="windows","c:/Repos","~/repos"); # modify as needed
setwd(paste(root,"/ExperimentTests/removals/",sep="")); # modify as needed
tlimit <- 100
burn.in <- 50
trtEffects=F
source("ipm/IPM-setup.r")
Spars$alpha <- read.csv("ipm/Gaussian-alphas.csv",row.names=1) #import alphas
Spars$alpha
Spars$alpha <- as.matrix(read.csv("ipm/Gaussian-alphas.csv",row.names=1)) #import alphas
Spars$alpha
alpha=Spars$alpha
is.matrix(alpha)
is.numeric(alpha)
source("ipm/IPM-getEquilibrium.r")
tlimit <- 1500
burn.in <- 500
trtEffects=F
source("ipm/IPM-setup.r")
Spars$alpha <- as.matrix(read.csv("ipm/Gaussian-alphas.csv",row.names=1)) #import alphas
source("ipm/IPM-getEquilibrium.r")
tlimit <- 1500
burn.in <- 500
trtEffects=T
source("ipm/IPM-setup.r")
Spars$alpha <- as.matrix(read.csv("ipm/Gaussian-alphas.csv",row.names=1)) #import alphas
source("ipm/IPM-getEquilibrium.r")
Spars.new <- Spars
Gpars.new <- Gpras
Gpars.new <- Gpars
Rpars.new <- Rpars
# Multispecies, spatially implicit IPM
# This version makes it possible to assume "no overlap"
# for intraspecific competition only or intra- and interspecific competition
# PBA 11/19/09
# paths updated 11/2015
rm(list=ls(all=TRUE))
graphics.off();
root=ifelse(.Platform$OS.type=="windows","c:/repos","~/repos"); # modify as needed
setwd(paste(root,"/drivers/StorageEffectEmpirical/multispp_glm_v3",sep="")); # modify as needed
outfile1="ipm_cover.csv"
outfile1b="ipm_cover_v2.csv"   # contains parameter years in output
outfile2="stable_size.csv"
A=10000 #Area of 100cm x 100cm quadrat
tlimit=500  ## number of years to simulate
burn.in=100    # years to cut before calculations
sppList=c("ARTR","HECO","POSE","PSSP")
bigM=c(75,75,50,50)     #Set matrix dimension for each species
maxSize=c(3000,202,260,225)    # in cm^2: PSSP=225 HECO=202  POSE=260  ARTR=3000  # minSize=0.2  cm^2
Nyrs=22
doGroup=NA  # NA for spatial avg., values 1-6 for a specific group
constant=F
NoOverlap.Inter=F  # T: heterospecific genets cannot spatially overlap; F: overlap allowed
#============================================================
# (I) LOAD VITAL RATE PARAMETERS & FUNCTIONS
#============================================================
Nspp=length(sppList)
# set up survival parameters and function
source("survival/import2ipm_noOverlap.r")
# set up growth parameters and function
source("growth/import2ipm_noOverlap.r")
# set up recruitment parameters and function
source("recruitment/import2ipm.r")
Spars
Spars$intcpt
Spars.new$intcpt
Spars
Gpars
source("validate/get_W_functions.r")  # get neighbor distance decay functions
#no treatment effects, all species present
init.species <- c(1:4)
tlimit <- 1500
burn.in <- 500
trtEffects=F
source("ipm/IPM-setup.r")
# call all scripts for removal experiment analysis
rm(list=ls(all=TRUE))
graphics.off();
root=ifelse(.Platform$OS.type=="windows","c:/Repos","~/repos"); # modify as needed
setwd(paste(root,"/ExperimentTests/removals/",sep="")); # modify as needed
source("validate/get_W_functions.r")  # get neighbor distance decay functions
#no treatment effects, all species present
init.species <- c(1:4)
tlimit <- 1500
burn.in <- 500
trtEffects=F
source("ipm/IPM-setup.r")
v
#no treatment effects, all species present
init.species <- c(1:4)
tlimit <- 100
burn.in <- 50
trtEffects=F
source("ipm/IPM-setup.r")
source("ipm/IPM-getEquilibrium.r")
Spars$alpha <- as.matrix(read.csv("ipm/Gaussian-alphas.csv",row.names=1))
source("ipm/IPM-getEquilibrium.r")
init.species
source("ipm/IPM-getEquilibrium.r")
#no treatment effects, all species present
init.species <- c(4)
tlimit <- 100
burn.in <- 50
trtEffects=F
source("ipm/IPM-setup.r")
Spars$alpha <- as.matrix(read.csv("ipm/Gaussian-alphas.csv",row.names=1))
source("ipm/IPM-getEquilibrium.r")
#no treatment effects, all species present
init.species <- c(4)
tlimit <- 1000
burn.in <- 500
trtEffects=F
source("ipm/IPM-setup.r")
Spars$alpha <- as.matrix(read.csv("ipm/Gaussian-alphas.csv",row.names=1))
source("ipm/IPM-getEquilibrium.r")
trtEffects=T
source("ipm/IPM-setup.r")
Spars$alpha <- as.matrix(read.csv("ipm/Gaussian-alphas.csv",row.names=1))
source("ipm/IPM-getEquilibrium.r")
boxplot(as.data.frame(100*covSave[(burn.in+1):tlimit,]),ylab="Cover (%)",names=sppList,col=myCol)
abline(h=0)
boxplot(as.data.frame(Nsave[(burn.in+1):tlimit,]),ylab="Density",names=sppList,col=myCol)
abline(h=0)
plot(1,1,type="n",xlim=c(log(0.15),log(max(maxSize*2))),ylim=c(0,0.1),
xlab="Size",ylab="Frequency")
for(i in 1:Nspp){
lines(v[[i]],rowMeans(sizeSave[[i]][,(burn.in+1):tlimit]),col=myCol[i])
}
# example time series
matplot((burn.in+1):tlimit,100*covSave[(burn.in+1):tlimit,],type="l",col=myCol,
xlab="Time",ylab="Cover (%)")
X11()
par(mfrow=c(2,2),tcl=-0.2)
for(i in 1:Nspp) {image(sizeSave[[i]][],x=v[[i]],y=1:tlimit,
xlab="size",ylab="time",main=sppList[i]) }
meanCover <- colMeans(covSave[(burn.in+1):tlimit,])
meanCover
meanCover <- colMeans(covSave[(burn.in+1):tlimit,])*100
meanCover
#no treatment effects, PSSP monoculture
init.species <- c(4)
tlimit <- 1000
burn.in <- 500
trtEffects=F
source("ipm/IPM-setup.r")
Spars$alpha <- as.matrix(read.csv("ipm/Gaussian-alphas.csv",row.names=1))
source("ipm/IPM-getEquilibrium.r")
print(meanCover)
# removal treatment effects, PSSP monoculture
init.species <- c(4)
trtEffects=T
source("ipm/IPM-setup.r")
Spars$alpha <- as.matrix(read.csv("ipm/Gaussian-alphas.csv",row.names=1))
source("ipm/IPM-getEquilibrium.r")
#no treatment effects, PSSP monoculture
init.species <- c(4)
tlimit <- 1000
burn.in <- 500
trtEffects=F
source("ipm/IPM-setup.r")
Spars$alpha <- as.matrix(read.csv("ipm/Gaussian-alphas.csv",row.names=1))
source("ipm/IPM-getEquilibrium.r")
meanCover1 <- meanCover
# removal treatment effects, PSSP monoculture
init.species <- c(4)
trtEffects=T
source("ipm/IPM-setup.r")
Spars$alpha <- as.matrix(read.csv("ipm/Gaussian-alphas.csv",row.names=1))
source("ipm/IPM-getEquilibrium.r")
meanCover2 <- meanCover
print(rbind(meanCover))
print(rbind(meanCover1,meanCover2))
source('C:/Repos/ExperimentTests/removals/removal_analysis_wrapper.r', echo=TRUE)
source("validate/get_W_functions.r")  # get neighbor distance decay functions
#no treatment effects, PSSP monoculture
init.species <- c(4)
tlimit <- 1000
burn.in <- 500
trtEffects=F
source("ipm/IPM-setup.r")
Spars$alpha <- as.matrix(read.csv("ipm/Gaussian-alphas.csv",row.names=1))
source("ipm/IPM-getEquilibrium.r")
meanCover1 <- meanCover
# removal treatment effects, PSSP monoculture
init.species <- c(4)
trtEffects=T
source("ipm/IPM-setup.r")
Spars$alpha <- as.matrix(read.csv("ipm/Gaussian-alphas.csv",row.names=1))
source("ipm/IPM-getEquilibrium.r")
meanCover2 <- meanCover
print(rbind(meanCover1,meanCover2))
setwd("..")
source("validate/get_W_functions.r")  # get neighbor distance decay functions
#no treatment effects, PSSP monoculture
init.species <- c(4)
tlimit <- 1000
burn.in <- 500
trtEffects=F
source("ipm/IPM-setup.r")
Spars$alpha <- as.matrix(read.csv("ipm/Gaussian-alphas.csv",row.names=1))
source("ipm/IPM-getEquilibrium.r")
source("validate/get_W_functions.r")  # get neighbor distance decay functions
#no treatment effects, PSSP monoculture
init.species <- c(4)
tlimit <- 1500
burn.in <- 500
trtEffects=F
source("ipm/IPM-setup.r")
Spars$alpha <- as.matrix(read.csv("ipm/Gaussian-alphas.csv",row.names=1))
source("ipm/IPM-getEquilibrium.r")
meanCover1 <- meanCover
# removal treatment effects, PSSP monoculture
init.species <- c(4)
trtEffects=T
source("ipm/IPM-setup.r")
Spars$alpha <- as.matrix(read.csv("ipm/Gaussian-alphas.csv",row.names=1))
source("ipm/IPM-getEquilibrium.r")
meanCover2 <- meanCover
print(rbind(meanCover1,meanCover2))
source('C:/Repos/ExperimentTests/removals/removal_analysis_wrapper.r', echo=TRUE)
setwd("..")
source("validate/get_W_functions.r")  # get neighbor distance decay functions
#no treatment effects, all species
init.species <- c(1:4)
tlimit <- 1500
burn.in <- 500
trtEffects=F
source("ipm/IPM-setup.r")
Spars$alpha <- as.matrix(read.csv("ipm/Gaussian-alphas.csv",row.names=1))
source("ipm/IPM-getEquilibrium.r")
meanCover1 <- meanCover
#no treatment effects, ARTR removal
init.species <- c(2:4)
source("ipm/IPM-getEquilibrium.r")
meanCover2 <- meanCover
# removal treatment effects, ARTR removal
init.species <- c(2:4)
trtEffects=T
source("ipm/IPM-setup.r")
Spars$alpha <- as.matrix(read.csv("ipm/Gaussian-alphas.csv",row.names=1))
source("ipm/IPM-getEquilibrium.r")
meanCover3 <- meanCover
print(rbind(meanCover1,meanCover2,meanCover3))
source('C:/Repos/Coexistence-Stability/modelCode/storage_effect.R', echo=TRUE)
cols2plot <- c(3,4)
matplot(saved_outs[101:seasons,cols2plot], type="l",
xlab="Season", ylab="Abundance",
main=expression(paste(alpha[1],"= 0.5; ", alpha[2],"=0.49; ", sigma[E],"=0.2")))
# lines(rowSums(saved_outs[101:seasons,cols2plot]), type="l", col="blue", lwd=2)
sd(rowSums(saved_outs[101:seasons,c(3:4)]))/mean(rowSums(saved_outs[101:seasons,c(3:4)]))
source('C:/Repos/Coexistence-Stability/modelCode/storage_effect.R', echo=TRUE)
source('C:/Repos/Coexistence-Stability/modelCode/storage_effect.R', echo=TRUE)
lines(rowSums(saved_outs[101:seasons,cols2plot]), type="l", col="blue", lwd=2)
saved_outs
source('C:/Repos/Coexistence-Stability/modelCode/storage_effect.R', echo=TRUE)
source('C:/Repos/Coexistence-Stability/modelCode/storage_effect.R', echo=TRUE)
rm(list=ls())
# call all scripts for removal experiment analysis
rm(list=ls(all=TRUE))
graphics.off();
root=ifelse(.Platform$OS.type=="windows","c:/Repos","~/repos"); # modify as needed
setwd(paste(root,"/ExperimentTests/removals/",sep="")); # modify as needed
distWts <- read.csv(paste0(root,"/driversdata/data/idaho/speciesdata/IdahoDistanceWeights.csv"))
distWts
source('C:/Repos/ExperimentTests/removals/validate/get_W_functions.r', echo=TRUE)
source('C:/Repos/ExperimentTests/removals/validate/get_W_functions.r', echo=TRUE)
zc
source('C:/Repos/ExperimentTests/removals/validate/get_W_functions.r', echo=TRUE)
source('C:/Repos/ExperimentTests/removals/validate/get_W_functions.r', echo=TRUE)
zc
source('C:/Repos/ExperimentTests/removals/validate/get_W_functions.r', echo=TRUE)
source('C:/Repos/ExperimentTests/removals/validate/get_W_functions.r', echo=TRUE)
zc
distWts
pi
?integrate
integrate(function(z) z*Wfuns[[i]](z), 0, zc[i])$value
i
i=1
integrate(function(z) z*Wfuns[[i]](z), 0, zc[i])$value
source('C:/Repos/ExperimentTests/removals/validate/get_W_functions.r', echo=TRUE)
W.constant
zc
# call all scripts for removal experiment analysis
rm(list=ls(all=TRUE))
graphics.off();
root=ifelse(.Platform$OS.type=="windows","c:/Repos","~/repos"); # modify as needed
setwd(paste(root,"/ExperimentTests/removals/",sep="")); # modify as needed
source("validate/get_W_functions.r")  # get neighbor distance decay functions
#no treatment effects, all species
init.species <- c(1:4)
tlimit <- 1500
burn.in <- 500
trtEffects=F
source("ipm/IPM-setup.r")
source("ipm/IPM-getEquilibrium.r")
Xbar
N
muW = Xbar*N*W.constant
muW
#no treatment effects, all species
init.species <- c(1:4)
tlimit <- 1500
burn.in <- 500
trtEffects=F
source("ipm/IPM-setup.r")
source("ipm/IPM-getEquilibrium.r")
#no treatment effects, all species
init.species <- c(1:4)
tlimit <- 1500
burn.in <- 500
trtEffects=F
source("ipm/IPM-setup.r")
source("ipm/IPM-getEquilibrium.r")
#no treatment effects, all species
init.species <- c(1:4)
tlimit <- 1500
burn.in <- 500
trtEffects=F
source("ipm/IPM-setup.r")
source("ipm/IPM-getEquilibrium.r")
Wmat[[1]]
#no treatment effects, all species
init.species <- c(1:4)
tlimit <- 1500
burn.in <- 500
trtEffects=F
source("ipm/IPM-setup.r")
source("ipm/IPM-getEquilibrium.r")
Wmat[[1]]
Q
#no treatment effects, all species
init.species <- c(1:4)
tlimit <- 1500
burn.in <- 500
trtEffects=F
source("ipm/IPM-setup.r")
source("ipm/IPM-getEquilibrium.r")
Wmat[[1]]
Wmat[[2]]
#no treatment effects, all species
init.species <- c(1:4)
tlimit <- 1500
burn.in <- 500
trtEffects=F
source("ipm/IPM-setup.r")
source("ipm/IPM-getEquilibrium.r")
meanCover1 <- meanCover
meanCover1
#no treatment effects, ARTR removal
init.species <- c(2:4)
source("ipm/IPM-getEquilibrium.r")
meanCover2 <- meanCover
# removal treatment effects, ARTR removal
init.species <- c(2:4)
trtEffects=T
source("ipm/IPM-setup.r")
Spars$alpha <- as.matrix(read.csv("ipm/Gaussian-alphas.csv",row.names=1))
source("ipm/IPM-getEquilibrium.r")
meanCover3 <- meanCover
print(rbind(meanCover1,meanCover2,meanCover3))
simResults <- rbind(meanCover1,meanCover2,meanCover3))
simResults <- rbind(meanCover1,meanCover2,meanCover3)
barplot(simResults,beside=T)
barplot(t(simResults),beside=T)
barplot(t(simResults))
barplot(simResults,beside=T)
axis(side=1,at=c(1:4),sppList)
axis(side=1,at=2.5*(1:4),sppList)
tmp <- barplot(simResults,beside=T)
tmp
tmp <- barplot(simResults,beside=T)
axis(side=1,at=tmp[2,],sppList)
myCol <- c("darkgrey","dodgerblue3","red3")
tmp <- barplot(simResults,beside=T,col=myCol)
axis(side=1,at=tmp[2,],sppList)
myCol <- c("black","gray","white")
tmp <- barplot(simResults,beside=T,col=myCol)
axis(side=1,at=tmp[2,],sppList)
myCol <- c("black","gray","white")
tmp <- barplot(simResults,beside=T,col=myCol,ylab="Cover (%)")
axis(side=1,at=tmp[2,],sppList)
legend("topright",c("Basline","Baseline, no ARTR","Removal effects"))
myCol <- c("black","gray","white")
tmp <- barplot(simResults,beside=T,col=myCol,ylab="Cover (%)")
axis(side=1,at=tmp[2,],sppList)
legend("topright",c("Basline","Baseline, no ARTR","Removal effects"),fill=myCol,bty="n")
par(tcl=-0.2,mgp=c(2,0,5,0))
myCol <- c("black","gray","white")
tmp <- barplot(simResults,beside=T,col=myCol,ylab="Cover (%)")
axis(side=1,at=tmp[2,],sppList)
legend("topright",c("Basline","Baseline, no ARTR","Removal effects"),fill=myCol,bty="n")
par(tcl=-0.2,mgp=c(2,0.5,0))
myCol <- c("black","gray","white")
tmp <- barplot(simResults,beside=T,col=myCol,ylab="Cover (%)")
axis(side=1,at=tmp[2,],sppList)
legend("topright",c("Basline","Baseline, no ARTR","Removal effects"),fill=myCol,bty="n")
par(tcl=-0.2,mgp=c(2,0.5,0))
myCol <- c("black","gray","white")
tmp <- barplot(simResults,beside=T,col=myCol,ylab="Cover (%)")
axis(side=1,at=tmp[2,],sppList)
legend("topright",c("Baseline","Baseline, no ARTR","Removal, no ARTR"),
fill=myCol,bty="n",cex=0.9)
# plot simulation results
par(tcl=-0.2,mgp=c(2,0.5,0))
myCol <- c("black","gray","white")
tmp <- barplot(simResults,beside=T,col=myCol,ylab="Cover (%)")
axis(side=1,at=tmp[2,],sppList,cex=0.9)
legend("topright",c("Baseline","Baseline, no ARTR","Removal, no ARTR"),
fill=myCol,bty="n",cex=0.9)
# plot simulation results
par(tcl=-0.2,mgp=c(2,0.5,0))
myCol <- c("black","gray","white")
tmp <- barplot(simResults,beside=T,col=myCol,ylab="Cover (%)")
axis(side=1,at=tmp[2,],sppList,cex=0.5)
legend("topright",c("Baseline","Baseline, no ARTR","Removal, no ARTR"),
fill=myCol,bty="n",cex=0.9)
# plot simulation results
par(tcl=-0.2,mgp=c(2,0.5,0))
myCol <- c("black","gray","white")
tmp <- barplot(simResults,beside=T,col=myCol,ylab="Cover (%)")
axis(side=1,at=tmp[2,],sppList,cex.lab=0.5)
legend("topright",c("Baseline","Baseline, no ARTR","Removal, no ARTR"),
fill=myCol,bty="n",cex=0.9)
?axis
par(tcl=-0.2,mgp=c(2,0.5,0))
myCol <- c("black","gray","white")
tmp <- barplot(simResults,beside=T,col=myCol,ylab="Cover (%)")
axis(side=1,at=tmp[2,],sppList,cex.axis=0.5)
legend("topright",c("Baseline","Baseline, no ARTR","Removal, no ARTR"),
fill=myCol,bty="n",cex=0.9)
par(tcl=-0.2,mgp=c(2,0.5,0))
myCol <- c("black","gray","white")
tmp <- barplot(simResults,beside=T,col=myCol,ylab="Cover (%)")
axis(side=1,at=tmp[2,],sppList,cex.axis=0.9)
legend("topright",c("Baseline","Baseline, no ARTR","Removal, no ARTR"),
fill=myCol,bty="n",cex=0.9)
# plot simulation results
png("IPMsims.png",height=3,width=4.5,units="in",res=400)
par(tcl=-0.2,mgp=c(2,0.5,0))
myCol <- c("black","gray","white")
tmp <- barplot(simResults,beside=T,col=myCol,ylab="Cover (%)")
axis(side=1,at=tmp[2,],sppList,cex.axis=0.9)
legend("topright",c("Baseline","Baseline, no ARTR","Removal, no ARTR"),
fill=myCol,bty="n",cex=0.9)
dev.off()
# plot simulation results
png("IPMsims.png",height=3,width=4.5,units="in",res=400)
par(tcl=-0.2,mgp=c(2,0.5,0),mara=c(3,3,1,1))
myCol <- c("black","gray","white")
tmp <- barplot(simResults,beside=T,col=myCol,ylab="Cover (%)")
axis(side=1,at=tmp[2,],sppList,cex.axis=0.9)
legend("topright",c("Baseline","Baseline, no ARTR","Removal, no ARTR"),
fill=myCol,bty="n",cex=0.9)
dev.off()
png("IPMsims.png",height=3,width=4.5,units="in",res=400)
par(tcl=-0.2,mgp=c(2,0.5,0),mar=c(3,3,1,1))
myCol <- c("black","gray","white")
tmp <- barplot(simResults,beside=T,col=myCol,ylab="Cover (%)")
axis(side=1,at=tmp[2,],sppList,cex.axis=0.9)
legend("topright",c("Baseline","Baseline, no ARTR","Removal, no ARTR"),
fill=myCol,bty="n",cex=0.9)
dev.off()
