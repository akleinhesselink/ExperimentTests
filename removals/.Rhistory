###
### 4. get IBM predictions for quadrat cover ###############################
###
sppList <-  c("ARTR","HECO","POSE","PSSP")
source("ibm/get_W_functions.r")  # get neighbor distance decay functions
# do contemporary control plots
quadList <- paste0("Q",c(1:6,19:26))
groupList <- c(rep(1,6),rep(6,4),rep(3,4))
removeSpp <- NULL
trtEffects <- FALSE  # TRUE means use a model that includes removal treatment effects
for(iQuad in 1:length(quadList)){
qName=quadList[iQuad]
doGroup=groupList[iQuad]
source("ibm/ibm_validate_removal.r")   # project forward from 2011
source("ibm/ibm_validate_removal_1step.r")  # just predict one time step ahead for each year
}
# do no grass plots
quadList <- c("Q48","Q49","Q51","Q55","Q57","Q58","Q60","Q62")  # no grass
removeSpp <- c("HECO","POSE","PSSP")
for(iQuad in quadList){
qName=iQuad
doGroup=1
trtEffects <- FALSE
source("ibm/ibm_validate_removal.r")
source("ibm/ibm_validate_removal_1step.r")
trtEffects <- TRUE
source("ibm/ibm_validate_removal.r")
source("ibm/ibm_validate_removal_1step.r")
}
# do no shrub plots
quadList <- c("Q47","Q50","Q52","Q53","Q54","Q56","Q59","Q61")  # no shrub
removeSpp <- c("ARTR")
for(iQuad in quadList){
qName=iQuad
doGroup=1
trtEffects <- FALSE
source("ibm/ibm_validate_removal.r")
source("ibm/ibm_validate_removal_1step.r")
trtEffects <- TRUE
source("ibm/ibm_validate_removal.r")
source("ibm/ibm_validate_removal_1step.r")
}
# make figure for simulation results
source("ibm/summarize_validate_sims1step.r")
###
### 5. get equilibrium cover from an IPM ###############################
###
sppList <-  c("ARTR","HECO","POSE","PSSP")
source("ibm/get_W_functions.r")  # get neighbor distance decay functions
#no treatment effects, all species
init.species <- c(1:4)
tlimit <- 2500
burn.in <- 500
trtEffects=F
source("ipm/IPM-setup.r")
source("ipm/IPM-getEquilibrium.r")
write.csv(covSave[(burn.in+1):tlimit,],"ipm/baselineCover.csv",row.names=F)
meanCover1 <- meanCover
#no treatment effects, ARTR removal
init.species <- c(2:4)
source("ipm/IPM-getEquilibrium.r")
write.csv(covSave[(burn.in+1):tlimit,],"ipm/baselineCover-noARTR.csv",row.names=F)
meanCover2 <- meanCover
# removal treatment effects, ARTR removal
init.species <- c(2:4)
trtEffects=T
source("ipm/IPM-setup.r")
source("ipm/IPM-getEquilibrium.r")
write.csv(covSave[(burn.in+1):tlimit,],"ipm/removalCover-noARTR.csv",row.names=F)
meanCover3 <- meanCover
# removal treatment effects, ARTR removal, no PSSP
init.species <- c(2:3)
trtEffects=T
source("ipm/IPM-setup.r")
source("ipm/IPM-getEquilibrium.r")
write.csv(covSave[(burn.in+1):tlimit,],"ipm/removalCover-noARTRnoPSSP.csv",row.names=F)
meanCover4 <- meanCover
simResults <- rbind(meanCover1,meanCover2,meanCover3,meanCover4)
colnames(simResults) <- sppList
write.csv(simResults,"ipm/simResults-meanCover.csv",row.names=F)
source("ipm/IPM-figures.r")
setwd("growth")
doSpp <- "PSSP"
sppList <- c("ARTR","HECO","POSE","PSSP","allcov","allpts")
dataDir1 <- paste(root,"/driversdata/data/idaho",sep="")
dataDir2 <- paste(root,"/driversdata/data/idaho_modern",sep="")
nonCompLength.s=5 #Number of columns in SppData that are not measures of competitors
# set up distance weights------------------------------------------------
#dists <- read.csv(paste(dataDir2,"/speciesdata/IdahoModDistanceWeights_noExptl.csv",sep=""));
dists$allcov <- rowMeans(dists[,1:4])  # for "other" polygons use average of big 4
dists$allpts <- dists$POSE  # set forb dist wts = smallest grass (POSE)
# import old data--------------------------------------------------------
source("fetchGrowthData.r")
D1 <- fetchGdat(doSpp=doSpp,speciesList=sppList,datadir=dataDir1,distWts=dists)
D1$Treatment <- "Control"
# import modern data--------------------------------------------------------
D2 <- fetchGdat(doSpp=doSpp,speciesList=sppList,datadir=dataDir2,distWts=dists)
# merge in treatment data
tmp <- read.csv(paste(dataDir2,"/quad_info.csv",sep=""))
tmp <- tmp[,c("quad","Treatment")]
D2 <- merge(D2,tmp, all.x=T)
# account for removal in baseline years
if(doSpp!="ARTR"){
ii <- which(D2$year>=2011 & D2$Treatment=="No_shrub")
D2$W.ARTR[ii] <- 0
}else{
ii <- which(D2$year>=2011 & D2$Treatment=="No_grass")
D2$W.HECO[ii] <- 0 ; D2$W.POSE[ii] <- 0 ; D2$W.PSSP[ii] <- 0
}
# combine old and modern
allD <- rbind(D1,D2)
rm(D1,D2,tmp)
# merge data on removals at individual level
tmp <- read.csv(paste(dataDir2,"/speciesData/",doSpp,"/",doSpp,"_within_ARTRremovals.csv",sep=""))
tmp <- tmp[,c("quad","year","trackID","inARTR")]
allD<-merge(allD,tmp,all.x=T)
allD$inARTR[is.na(allD$inARTR)] <- 0
# clean up dataset ----------------------------------------------
allD$year[allD$year<2000] <- allD$year[allD$year<2000] + 1900
if(doSpp=="ARTR"){
keep <- which(is.element(allD$Treatment,c("Control","No_grass")))
}else{
keep <- which(is.element(allD$Treatment,c("Control","No_shrub")))
}
allD <- allD[keep,]
# remove outliers (large plants that obviously do not turn into tiny plants)
#########################################
#  2. Fit models
#########################################
library(lme4)
# set up indicator variables
allD$Treatment2 <- allD$Treatment
allD$Treatment2[allD$year>2000] <- "Modern"
allD$Treatment3 <- allD$Treatment
allD$Treatment3[allD$Treatment=="Control" & allD$year>2000] <- "ControlModern"
allD$year <- as.factor(allD$year)
# use INLA
# Set up ID variables for INLA random effects
allD$GroupID <- as.numeric(allD$Group)
allD$yearID <- 100+as.numeric(allD$year) # for random year offset on intercept
# Explore alternative covariates and models using lmer
m0.lmer <- lmer(logarea.t1~logarea.t0+W.ARTR + W.HECO + W.POSE + W.PSSP+ W.allcov + W.allpts+
(1|Group)+(logarea.t0|year),data=allD)
m1.lmer <- lmer(logarea.t1~logarea.t0+Treatment+W.ARTR + W.HECO + W.POSE + W.PSSP+W.allcov + W.allpts+
(1|Group)+(logarea.t0|year),data=allD)
m2.lmer <- lmer(logarea.t1~logarea.t0+ Treatment + W.HECO + W.POSE + W.PSSP+ W.ARTR + W.allcov + W.allpts+
W.PSSP:Treatment+
(1|Group)+(logarea.t0|year),data=allD)
m3.lmer <- lmer(logarea.t1~logarea.t0+ Treatment + W.HECO + W.POSE + W.PSSP+ W.ARTR + W.allcov + W.allpts+
W.POSE:Treatment+ W.HECO:Treatment+W.PSSP:Treatment+
(1|Group)+(logarea.t0|year),data=allD)
print(c(AIC(m0.lmer),AIC(m1.lmer),AIC(m2.lmer),AIC(m3.lmer)))  # m2 is best
summary(m0.lmer)
m0.lmer <- lmer(logarea.t1~logarea.t0+W.ARTR + W.HECO + W.POSE + W.PSSP+ W.allcov + W.allpts+
(1|Group)+(logarea.t0|year),data=allD,subset=year<2000)
m0.lmer <- lmer(logarea.t1~logarea.t0+W.ARTR + W.HECO + W.POSE + W.PSSP+ W.allcov + W.allpts+
(1|Group)+(logarea.t0|year),data=allD,subset=Treatment2=="Modern")
summary(m0.lmer)
m0.lmer <- lmer(logarea.t1~logarea.t0+W.ARTR + W.HECO + W.POSE + W.PSSP+ W.allcov + W.allpts+
(1|Group)+(logarea.t0|year),data=allD,subset=Treatment2!="Modern")
summary(m0.lmer)
m0.lmer <- lmer(logarea.t1~logarea.t0+W.ARTR + W.HECO + W.POSE + W.PSSP+ W.allcov + W.allpts+
(1|Group)+(logarea.t0|year),data=allD,subset=Treatment2!="Modern")
summary(m0.lmer)
unique(allD$Treatment2)
m1.lmer <- lmer(logarea.t1~logarea.t0+Treatment+Treatment2+W.ARTR + W.HECO + W.POSE + W.PSSP+W.allcov + W.allpts+
(1|Group)+(logarea.t0|year),data=allD)
summary(m1.lmer)
m1.lmer <- lmer(logarea.t1~logarea.t0+Treatment+W.ARTR + W.HECO + W.POSE + W.PSSP+W.allcov + W.allpts+
(1|Group)+(logarea.t0|year),data=allD)
summary(m1.lmer)
summary(m2.lmer)
source('C:/Repos/ExperimentTests/removals/growth/PSSPgrowth.R', echo=TRUE)
setwd("..")
###
### 5. get equilibrium cover from an IPM ###############################
###
sppList <-  c("ARTR","HECO","POSE","PSSP")
source("ibm/get_W_functions.r")  # get neighbor distance decay functions
#no treatment effects, all species
init.species <- c(1:4)
tlimit <- 2500
burn.in <- 500
trtEffects=F
source("ipm/IPM-setup.r")
source("ipm/IPM-getEquilibrium.r")
write.csv(covSave[(burn.in+1):tlimit,],"ipm/baselineCover.csv",row.names=F)
meanCover1 <- meanCover
#no treatment effects, ARTR removal
init.species <- c(2:4)
source("ipm/IPM-getEquilibrium.r")
write.csv(covSave[(burn.in+1):tlimit,],"ipm/baselineCover-noARTR.csv",row.names=F)
meanCover2 <- meanCover
# removal treatment effects, ARTR removal
init.species <- c(2:4)
trtEffects=T
source("ipm/IPM-setup.r")
source("ipm/IPM-getEquilibrium.r")
write.csv(covSave[(burn.in+1):tlimit,],"ipm/removalCover-noARTR.csv",row.names=F)
meanCover3 <- meanCover
# removal treatment effects, ARTR removal, no PSSP
init.species <- c(2:3)
trtEffects=T
source("ipm/IPM-setup.r")
source("ipm/IPM-getEquilibrium.r")
write.csv(covSave[(burn.in+1):tlimit,],"ipm/removalCover-noARTRnoPSSP.csv",row.names=F)
meanCover4 <- meanCover
simResults <- rbind(meanCover1,meanCover2,meanCover3,meanCover4)
colnames(simResults) <- sppList
write.csv(simResults,"ipm/simResults-meanCover.csv",row.names=F)
source("ipm/IPM-figures.r")
simResults
Gpars
summary(m1.lmer)
AIC(m1.lmer)
#########################################
#  1. Import data and calculate W's
#########################################
doSpp <- "PSSP"
sppList <- c("ARTR","HECO","POSE","PSSP","allcov","allpts")
dataDir1 <- paste(root,"/driversdata/data/idaho",sep="")
dataDir2 <- paste(root,"/driversdata/data/idaho_modern",sep="")
nonCompLength.s=5 #Number of columns in SppData that are not measures of competitors
# set up distance weights------------------------------------------------
dists <- read.csv(paste(dataDir1,"/speciesdata/IdahoDistanceWeights.csv",sep=""))
#dists <- read.csv(paste(dataDir2,"/speciesdata/IdahoModDistanceWeights_noExptl.csv",sep=""));
dists$allcov <- rowMeans(dists[,1:4])  # for "other" polygons use average of big 4
dists$allpts <- dists$POSE  # set forb dist wts = smallest grass (POSE)
# import old data--------------------------------------------------------
source("fetchGrowthData.r")
D1 <- fetchGdat(doSpp=doSpp,speciesList=sppList,datadir=dataDir1,distWts=dists)
D1$Treatment <- "Control"
# import modern data--------------------------------------------------------
D2 <- fetchGdat(doSpp=doSpp,speciesList=sppList,datadir=dataDir2,distWts=dists)
# merge in treatment data
tmp <- read.csv(paste(dataDir2,"/quad_info.csv",sep=""))
tmp <- tmp[,c("quad","Treatment")]
D2 <- merge(D2,tmp, all.x=T)
# account for removal in baseline years
if(doSpp!="ARTR"){
ii <- which(D2$year>=2011 & D2$Treatment=="No_shrub")
D2$W.ARTR[ii] <- 0
}else{
ii <- which(D2$year>=2011 & D2$Treatment=="No_grass")
D2$W.HECO[ii] <- 0 ; D2$W.POSE[ii] <- 0 ; D2$W.PSSP[ii] <- 0
}
# combine old and modern
allD <- rbind(D1,D2)
rm(D1,D2,tmp)
# merge data on removals at individual level
tmp <- read.csv(paste(dataDir2,"/speciesData/",doSpp,"/",doSpp,"_within_ARTRremovals.csv",sep=""))
tmp <- tmp[,c("quad","year","trackID","inARTR")]
allD<-merge(allD,tmp,all.x=T)
allD$inARTR[is.na(allD$inARTR)] <- 0
# clean up dataset ----------------------------------------------
allD$year[allD$year<2000] <- allD$year[allD$year<2000] + 1900
if(doSpp=="ARTR"){
keep <- which(is.element(allD$Treatment,c("Control","No_grass")))
}else{
keep <- which(is.element(allD$Treatment,c("Control","No_shrub")))
}
allD <- allD[keep,]
# remove outliers (large plants that obviously do not turn into tiny plants)
dists <- read.csv(paste(dataDir1,"/speciesData/IdahoDistanceWeights.csv",sep=""))
getwd()
getwd()
setwd("growth")
doSpp <- "PSSP"
sppList <- c("ARTR","HECO","POSE","PSSP","allcov","allpts")
dataDir1 <- paste(root,"/driversdata/data/idaho",sep="")
dataDir2 <- paste(root,"/driversdata/data/idaho_modern",sep="")
nonCompLength.s=5 #Number of columns in SppData that are not measures of competitors
# set up distance weights------------------------------------------------
dists <- read.csv(paste(dataDir1,"/speciesData/IdahoDistanceWeights.csv",sep=""))
#dists <- read.csv(paste(dataDir2,"/speciesdata/IdahoModDistanceWeights_noExptl.csv",sep=""));
dists$allcov <- rowMeans(dists[,1:4])  # for "other" polygons use average of big 4
dists$allpts <- dists$POSE  # set forb dist wts = smallest grass (POSE)
# import old data--------------------------------------------------------
source("fetchGrowthData.r")
D1 <- fetchGdat(doSpp=doSpp,speciesList=sppList,datadir=dataDir1,distWts=dists)
D1$Treatment <- "Control"
# import modern data--------------------------------------------------------
D2 <- fetchGdat(doSpp=doSpp,speciesList=sppList,datadir=dataDir2,distWts=dists)
# merge in treatment data
tmp <- read.csv(paste(dataDir2,"/quad_info.csv",sep=""))
tmp <- tmp[,c("quad","Treatment")]
D2 <- merge(D2,tmp, all.x=T)
# account for removal in baseline years
if(doSpp!="ARTR"){
ii <- which(D2$year>=2011 & D2$Treatment=="No_shrub")
D2$W.ARTR[ii] <- 0
}else{
ii <- which(D2$year>=2011 & D2$Treatment=="No_grass")
D2$W.HECO[ii] <- 0 ; D2$W.POSE[ii] <- 0 ; D2$W.PSSP[ii] <- 0
}
# combine old and modern
allD <- rbind(D1,D2)
rm(D1,D2,tmp)
# merge data on removals at individual level
tmp <- read.csv(paste(dataDir2,"/speciesData/",doSpp,"/",doSpp,"_within_ARTRremovals.csv",sep=""))
tmp <- tmp[,c("quad","year","trackID","inARTR")]
allD<-merge(allD,tmp,all.x=T)
allD$inARTR[is.na(allD$inARTR)] <- 0
# clean up dataset ----------------------------------------------
allD$year[allD$year<2000] <- allD$year[allD$year<2000] + 1900
if(doSpp=="ARTR"){
keep <- which(is.element(allD$Treatment,c("Control","No_grass")))
}else{
keep <- which(is.element(allD$Treatment,c("Control","No_shrub")))
}
allD <- allD[keep,]
# remove outliers (large plants that obviously do not turn into tiny plants)
m1.lmer <- lmer(logarea.t1~logarea.t0+Treatment+W.ARTR + W.HECO + W.POSE + W.PSSP+W.allcov + W.allpts+
(1|Group)+(logarea.t0|year),data=allD)
AIC(m1.lmer)
summary(m1.lmer)
source('C:/Repos/ExperimentTests/removals/removal_analysis_wrapper.r', echo=TRUE)
names(allD)
source('C:/Repos/ExperimentTests/removals/removal_analysis_wrapper.r', echo=TRUE)
plot(1:30,pch=1:30)
par(mfrow=c(1,1))
plot(1:25,pch=1:25)
source('C:/Repos/ExperimentTests/removals/ibm/summarize_validate_sims1step.r', echo=TRUE)
?pch
source('C:/Repos/ExperimentTests/removals/ibm/summarize_validate_sims1step.r', echo=TRUE)
source('C:/Repos/ExperimentTests/removals/ibm/summarize_validate_sims1step.r', echo=TRUE)
source('C:/Repos/ExperimentTests/removals/ibm/summarize_validate_sims1step.r', echo=TRUE)
dev.off()
setwd("..")
source('C:/Repos/ExperimentTests/removals/ibm/summarize_validate_sims1step.r', echo=TRUE)
setwd("..")
getwd()
setwd("ExperimentTests/removals")
source('C:/Repos/ExperimentTests/removals/ibm/summarize_validate_sims1step.r', echo=TRUE)
source('C:/Repos/ExperimentTests/removals/ibm/summarize_validate_sims1step.r', echo=TRUE)
source('C:/Repos/ExperimentTests/removals/ibm/summarize_validate_sims1step.r', echo=TRUE)
source('C:/Repos/ExperimentTests/removals/ibm/summarize_validate_sims1step.r', echo=TRUE)
# call from removal_analysis_wrapper.r
sppList=c("Artemisia tripartita","Hesperostipa comata","Poa secunda","Pseudoroegneria spicata")
dataDir <- paste(root,"/driversdata/data/idaho_modern/",sep="")
# import data and calculate treatment trends ######################################
covD<-read.csv(paste(dataDir,"allrecords_cover.csv",sep=""))
trts<-read.csv(paste(dataDir,"quad_info.csv",sep=""))
# use this to make sure we don't miss zeros
allquadyrs<-unique(covD[,c("quad","year")],MARGIN=2)
tmp<-expand.grid(species=sppList,year=sort(unique(covD$year)))
allquadyrs<-merge(allquadyrs,tmp,all=T)
allquadyrs<-merge(allquadyrs,trts[,c("Group","quad","Treatment")])
# focus on exclosures
allquadyrs <- subset(allquadyrs,Group=="E1")
# only do removal treatments
keep <- which(is.element(allquadyrs$Treatment,c("Control","No_shrub","No_grass")))
allquadyrs <- allquadyrs[keep,]
# calculate treatment means by year
keep<-which(is.element(covD$species,sppList))
sppD<-covD[keep,]
sppD<-merge(sppD,allquadyrs,all.y=T)
sppD$area[is.na(sppD$area)]<-0
sppD$area<-sppD$area*100
sppD.q<-aggregate(sppD$area,by=list(species=sppD$species,Treatment=sppD$Treatment,
quad=sppD$quad,year=sppD$year),FUN=sum)
names(sppD.q)[NCOL(sppD.q)]<-"cover"
spp.mean <- aggregate(sppD.q$cover,by=list(species=sppD.q$species,Treatment=sppD.q$Treatment,
year=sppD.q$year),FUN=mean)
names(spp.mean)[NCOL(spp.mean)] <- "cover"
spp.mean <- reshape(spp.mean,direction="wide",timevar="Treatment",idvar=c("species","year"))
spp.mean <- subset(spp.mean,year>2010)
spp.mean <- spp.mean[order(spp.mean$species,spp.mean$year),]
# calculate year-to-year log changes
tmp <- sppD.q
tmp$year <- tmp$year + 1
names(tmp)[which(names(tmp)=="cover")] <- "lag.cover"
logChange <- merge(sppD.q,tmp)
logChange$pcgr <- log(logChange$cover/logChange$lag.cover)
logChange$pcgr[logChange$pcgr==Inf] <- NA
logChange$pcgr[logChange$pcgr==-Inf] <- NA
mean.change <- aggregate(logChange$pcgr,by=list(species=logChange$species,Treatment=logChange$Treatment,
year=logChange$year),FUN=mean,na.rm=T)
names(mean.change)[NCOL(mean.change)] <- "pcgr"
mean.change <- subset(mean.change,year>2010)
mean.change <- reshape(mean.change,direction="wide",timevar="Treatment",idvar=c("species","year"))
mean.change <- mean.change[order(mean.change$species,mean.change$year),]
# calculate deviations from pretreatment year
sppD.q.2011<-subset(sppD.q,year==2011) #get pre-treatment year
names(sppD.q.2011)[NCOL(sppD.q.2011)]<-"cover.2011"
i<-which(names(sppD.q.2011)=="year")
sppD.q.2011<-sppD.q.2011[,-i]
sppD.q<-subset(sppD.q,year>2010)
sppD.q<-merge(sppD.q,sppD.q.2011)
sppD.q$coverDiff<-sppD.q$cover-sppD.q$cover.2011
spp.mean.diff<-aggregate(sppD.q$coverDiff,by=list(species=sppD.q$species,Treatment=sppD.q$Treatment,
year=sppD.q$year),FUN=mean)
names(spp.mean.diff)[NCOL(spp.mean.diff)]<-"coverDiff"
spp.mean.diff <- reshape(spp.mean.diff,direction="wide",timevar="Treatment",idvar=c("species","year"))
spp.mean.diff <- spp.mean.diff[order(spp.mean.diff$species,spp.mean.diff$year),]
# statistical tests ####################################################
library(lme4)
dARTR <- subset(logChange,species=="Artemisia tripartita" & !is.na(pcgr) & Treatment!="No_shrub")
dARTR$year <- as.factor(dARTR$year)
mARTR <- lmer(pcgr ~ Treatment + (1|quad) + (1|year),data=dARTR)
summary(mARTR)
dHECO <- subset(logChange,species=="Hesperostipa comata" & !is.na(pcgr) & Treatment!="No_grass")
dHECO$year <- as.factor(dHECO$year)
mHECO <- lmer(pcgr ~ Treatment + (1|quad) + (1|year),data=dHECO)
summary(mHECO)  # significant
dPOSE <- subset(logChange,species=="Poa secunda" & !is.na(pcgr) & Treatment!="No_grass")
dPOSE$year <- as.factor(dPOSE$year)
mPOSE <- lmer(pcgr ~ Treatment + (1|quad) + (1|year),data=dPOSE)
summary(mPOSE)
dPSSP <- subset(logChange,species=="Pseudoroegneria spicata" & !is.na(pcgr) & Treatment!="No_grass")
dPSSP$year <- as.factor(dPSSP$year)
mPSSP <- lmer(pcgr ~ Treatment + (1|quad) + (1|year),data=dPSSP)
summary(mPSSP)  # significant
spp.mean
trtLabels<-substr(x=names(spp.mean)[3:5],start=7,stop=nchar(names(spp.mean)[3:5]))
myCols<-c("black","darkgoldenrod","darkgreen")
#1. Average cover treatment and year
png("treatment_trends_cover.png",height=2.75,width=8,units="in",res=400)
par(mfrow=c(1,4),mgp=c(2,0.5,0),mar=c(2,2,2,1),oma=c(2,2,0,0),tcl=-0.2)
# mean cover
for(doSpp in sppList){
tmp.mean<-subset(spp.mean,species==doSpp)
my.y <- ifelse(doSpp==1, c(0,max(tmp.mean[,3:5]),c(0,2.75))
matplot(tmp.mean$year,tmp.mean[,3:5],ylim=my.y,type="o",xlab="",ylab="",pch=16,lty="solid",
col=myCols,main=doSpp,font.main=4,lwd=2)
if(doSpp==sppList[1]) {
legend("topright",c("Control","Grass removal","Shrub removal"),pch=16,lty="solid",col=myCols,bty="n")
mtext("Mean cover (%)",side=2,line=2,outer=F)
}
}
mtext("Year",side=1,line=1,outer=T)
dev.off()
png("treatment_trends_cover.png",height=2.75,width=8,units="in",res=400)
par(mfrow=c(1,4),mgp=c(2,0.5,0),mar=c(2,2,2,1),oma=c(2,2,0,0),tcl=-0.2)
# mean cover
for(doSpp in sppList){
tmp.mean<-subset(spp.mean,species==doSpp)
my.y <- ifelse(doSpp==1, c(0,max(tmp.mean[,3:5])),c(0,2.75))
matplot(tmp.mean$year,tmp.mean[,3:5],ylim=my.y,type="o",xlab="",ylab="",pch=16,lty="solid",
col=myCols,main=doSpp,font.main=4,lwd=2)
if(doSpp==sppList[1]) {
legend("topright",c("Control","Grass removal","Shrub removal"),pch=16,lty="solid",col=myCols,bty="n")
mtext("Mean cover (%)",side=2,line=2,outer=F)
}
}
mtext("Year",side=1,line=1,outer=T)
dev.off()
my.y
#1. Average cover treatment and year
png("treatment_trends_cover.png",height=2.75,width=8,units="in",res=400)
par(mfrow=c(1,4),mgp=c(2,0.5,0),mar=c(2,2,2,1),oma=c(2,2,0,0),tcl=-0.2)
# mean cover
for(doSpp in sppList){
tmp.mean<-subset(spp.mean,species==doSpp)
my.y <- ifelse(doSpp==sppList[1], c(0,max(tmp.mean[,3:5])),c(0,2.75))
matplot(tmp.mean$year,tmp.mean[,3:5],ylim=my.y,type="o",xlab="",ylab="",pch=16,lty="solid",
col=myCols,main=doSpp,font.main=4,lwd=2)
if(doSpp==sppList[1]) {
legend("topright",c("Control","Grass removal","Shrub removal"),pch=16,lty="solid",col=myCols,bty="n")
mtext("Mean cover (%)",side=2,line=2,outer=F)
}
}
mtext("Year",side=1,line=1,outer=T)
dev.off()
my.y
>ifelse
?ifelse
sppList
doSpp
c(0,max(tmp.mean[,3:5]))
c(0,2.75)
#1. Average cover treatment and year
png("treatment_trends_cover.png",height=2.75,width=8,units="in",res=400)
par(mfrow=c(1,4),mgp=c(2,0.5,0),mar=c(2,2,2,1),oma=c(2,2,0,0),tcl=-0.2)
# mean cover
for(doSpp in sppList){
tmp.mean<-subset(spp.mean,species==doSpp)
if(doSpp==sppList[1]){
my.y <- c(0,max(tmp.mean[,3:5]))
}else{
my.y<- c(0,2.75))
}
matplot(tmp.mean$year,tmp.mean[,3:5],ylim=my.y,type="o",xlab="",ylab="",pch=16,lty="solid",
col=myCols,main=doSpp,font.main=4,lwd=2)
if(doSpp==sppList[1]) {
legend("topright",c("Control","Grass removal","Shrub removal"),pch=16,lty="solid",col=myCols,bty="n")
mtext("Mean cover (%)",side=2,line=2,outer=F)
}
}
mtext("Year",side=1,line=1,outer=T)
dev.off()
png("treatment_trends_cover.png",height=2.75,width=8,units="in",res=400)
par(mfrow=c(1,4),mgp=c(2,0.5,0),mar=c(2,2,2,1),oma=c(2,2,0,0),tcl=-0.2)
# mean cover
for(doSpp in sppList){
tmp.mean<-subset(spp.mean,species==doSpp)
if(doSpp==sppList[1]){
my.y <- c(0,max(tmp.mean[,3:5]))
}else{
my.y<- c(0,2.75)
}
matplot(tmp.mean$year,tmp.mean[,3:5],ylim=my.y,type="o",xlab="",ylab="",pch=16,lty="solid",
col=myCols,main=doSpp,font.main=4,lwd=2)
if(doSpp==sppList[1]) {
legend("topright",c("Control","Grass removal","Shrub removal"),pch=16,lty="solid",col=myCols,bty="n")
mtext("Mean cover (%)",side=2,line=2,outer=F)
}
}
mtext("Year",side=1,line=1,outer=T)
dev.off()
source('C:/Repos/ExperimentTests/removals/treatment_trends_removals.r', echo=TRUE)
source('C:/temp/normal_community.R', echo=TRUE)
